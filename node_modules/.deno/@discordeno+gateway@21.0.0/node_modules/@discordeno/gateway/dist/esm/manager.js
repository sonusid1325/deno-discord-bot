import { randomBytes } from 'node:crypto';
import { GatewayIntents, GatewayOpcodes } from '@discordeno/types';
import { Collection, delay, logger } from '@discordeno/utils';
import Shard from './Shard.js';
import { ShardSocketCloseCodes } from './types.js';
export function createGatewayManager(options) {
    const connectionOptions = options.connection ?? {
        url: 'wss://gateway.discord.gg',
        shards: 1,
        sessionStartLimit: {
            maxConcurrency: 1,
            remaining: 1000,
            total: 1000,
            resetAfter: 1000 * 60 * 60 * 24
        }
    };
    const gateway = {
        events: options.events ?? {},
        compress: options.compress ?? false,
        transportCompression: options.transportCompression ?? null,
        intents: options.intents ?? 0,
        properties: {
            os: options.properties?.os ?? process.platform,
            browser: options.properties?.browser ?? 'Discordeno',
            device: options.properties?.device ?? 'Discordeno'
        },
        token: options.token,
        url: options.url ?? connectionOptions.url ?? 'wss://gateway.discord.gg',
        version: options.version ?? 10,
        connection: connectionOptions,
        totalShards: options.totalShards ?? connectionOptions.shards ?? 1,
        lastShardId: options.lastShardId ?? (options.totalShards ? options.totalShards - 1 : connectionOptions ? connectionOptions.shards - 1 : 0),
        firstShardId: options.firstShardId ?? 0,
        totalWorkers: options.totalWorkers ?? 4,
        shardsPerWorker: options.shardsPerWorker ?? 25,
        spawnShardDelay: options.spawnShardDelay ?? 5300,
        preferSnakeCase: options.preferSnakeCase ?? false,
        shards: new Map(),
        buckets: new Map(),
        cache: {
            requestMembers: {
                enabled: options.cache?.requestMembers?.enabled ?? false,
                pending: new Collection()
            }
        },
        logger: options.logger ?? logger,
        makePresence: options.makePresence ?? (()=>Promise.resolve(undefined)),
        resharding: {
            enabled: options.resharding?.enabled ?? true,
            shardsFullPercentage: options.resharding?.shardsFullPercentage ?? 80,
            checkInterval: options.resharding?.checkInterval ?? 28800000,
            shards: new Collection(),
            pendingShards: new Collection(),
            getSessionInfo: options.resharding?.getSessionInfo,
            updateGuildsShardId: options.resharding?.updateGuildsShardId,
            async checkIfReshardingIsNeeded () {
                gateway.logger.debug('[Resharding] Checking if resharding is needed.');
                if (!gateway.resharding.enabled) {
                    gateway.logger.debug('[Resharding] Resharding is disabled.');
                    return {
                        needed: false
                    };
                }
                if (!gateway.resharding.getSessionInfo) {
                    throw new Error("[Resharding] Resharding is enabled but no 'resharding.getSessionInfo()' is not provided.");
                }
                gateway.logger.debug('[Resharding] Resharding is enabled.');
                const sessionInfo = await gateway.resharding.getSessionInfo();
                gateway.logger.debug(`[Resharding] Session info retrieved: ${JSON.stringify(sessionInfo)}`);
                // Don't have enough identify limits to try resharding
                if (sessionInfo.sessionStartLimit.remaining < sessionInfo.shards) {
                    gateway.logger.debug('[Resharding] Not enough session start limits left to reshard.');
                    return {
                        needed: false,
                        info: sessionInfo
                    };
                }
                gateway.logger.debug('[Resharding] Able to reshard, checking whether necessary now.');
                // 2500 is the max amount of guilds a single shard can handle
                // 1000 is the amount of guilds discord uses to determine how many shards to recommend.
                // This algo helps check if your bot has grown enough to reshard.
                // While this is imprecise as discord changes the recommended number of shard every 1000 guilds it is good enough
                // The alternative is to store the guild count for each shard and require the Guilds intent for `GUILD_CREATE` and `GUILD_DELETE` events
                const percentage = sessionInfo.shards / (gateway.totalShards * 2500 / 1000) * 100;
                // Less than necessary% being used so do nothing
                if (percentage < gateway.resharding.shardsFullPercentage) {
                    gateway.logger.debug('[Resharding] Resharding not needed.');
                    return {
                        needed: false,
                        info: sessionInfo
                    };
                }
                gateway.logger.info('[Resharding] Resharding is needed.');
                return {
                    needed: true,
                    info: sessionInfo
                };
            },
            async reshard (info) {
                gateway.logger.info(`[Resharding] Starting the reshard process. Previous total shards: ${gateway.totalShards}`);
                // Set values on gateway
                gateway.totalShards = info.shards;
                // Handles preparing mid sized bots for LBS
                gateway.totalShards = gateway.calculateTotalShards();
                // Set first shard id if provided in info
                if (typeof info.firstShardId === 'number') gateway.firstShardId = info.firstShardId;
                // Set last shard id if provided in info
                if (typeof info.lastShardId === 'number') gateway.lastShardId = info.lastShardId;
                gateway.logger.info(`[Resharding] Starting the reshard process. New total shards: ${gateway.totalShards}`);
                // Resetting buckets
                gateway.buckets.clear();
                // Refilling buckets with new values
                gateway.prepareBuckets();
                // SPREAD THIS OUT TO DIFFERENT WORKERS TO BEGIN STARTING UP
                gateway.buckets.forEach(async (bucket, bucketId)=>{
                    for (const worker of bucket.workers){
                        for (const shardId of worker.queue){
                            await gateway.resharding.tellWorkerToPrepare(worker.id, shardId, bucketId);
                        }
                    }
                });
            },
            async tellWorkerToPrepare (workerId, shardId, bucketId) {
                gateway.logger.debug(`[Resharding] Telling worker to prepare. Worker: ${workerId} | Shard: ${shardId} | Bucket: ${bucketId}.`);
                const shard = new Shard({
                    id: shardId,
                    connection: {
                        compress: gateway.compress,
                        transportCompression: gateway.transportCompression ?? null,
                        intents: gateway.intents,
                        properties: gateway.properties,
                        token: gateway.token,
                        totalShards: gateway.totalShards,
                        url: gateway.url,
                        version: gateway.version
                    },
                    // Ignore events until we are ready
                    events: {
                        async message (_shard, payload) {
                            if (payload.t === 'READY') {
                                await gateway.resharding.updateGuildsShardId?.(payload.d.guilds.map((g)=>g.id), shardId);
                            }
                        }
                    },
                    logger: gateway.logger,
                    requestIdentify: async ()=>{
                        await gateway.identify(shardId);
                    },
                    shardIsReady: async ()=>{
                        gateway.logger.debug(`[Shard] Shard #${shardId} is ready`);
                        await delay(gateway.spawnShardDelay);
                        gateway.logger.debug(`[Shard] Resolving shard identify request`);
                        gateway.buckets.get(shardId % gateway.connection.sessionStartLimit.maxConcurrency).identifyRequests.shift()?.();
                    },
                    makePresence: gateway.makePresence
                });
                if (gateway.preferSnakeCase) {
                    shard.forwardToBot = async (payload)=>{
                        shard.events?.message?.(shard, payload);
                    };
                }
                gateway.resharding.shards.set(shardId, shard);
                const bucket = gateway.buckets.get(shardId % gateway.connection.sessionStartLimit.maxConcurrency);
                if (!bucket) return;
                return await new Promise((resolve)=>{
                    // Mark that we are making an identify request so another is not made.
                    bucket.identifyRequests.push(resolve);
                    gateway.logger.debug(`[Gateway] Identifying Shard #${shardId}.`);
                    // This will trigger identify and when READY is received it will resolve the above request.
                    shard?.identify().then(async ()=>{
                        // Tell the manager that this shard is online
                        return await gateway.resharding.shardIsPending(shard);
                    });
                });
            },
            async shardIsPending (shard) {
                // Save this in pending at the moment, until all shards are online
                gateway.resharding.pendingShards.set(shard.id, shard);
                gateway.logger.debug(`[Resharding] Shard #${shard.id} is now pending.`);
                // Check if all shards are now online.
                if (gateway.lastShardId - gateway.firstShardId >= gateway.resharding.pendingShards.size) return;
                gateway.logger.info(`[Resharding] All shards are now online.`);
                // New shards start processing events
                for (const shard of gateway.resharding.shards.values()){
                    for(const event in options.events){
                        shard.events[event] = options.events[event];
                    }
                }
                // Old shards stop processing events
                for (const shard of gateway.shards.values()){
                    const oldHandler = shard.events.message;
                    // Change with spread operator to not affect new shards, as changing anything on shard.events will directly change options.events, which changes new shards' events
                    shard.events = {
                        ...shard.events,
                        message: async function(_, message) {
                            // Member checks need to continue but others can stop
                            if (message.t === 'GUILD_MEMBERS_CHUNK') {
                                oldHandler?.(shard, message);
                            }
                        }
                    };
                }
                gateway.logger.info(`[Resharding] Shutting down old shards.`);
                // Close old shards
                await gateway.shutdown(ShardSocketCloseCodes.Resharded, 'Resharded!', false);
                gateway.logger.info(`[Resharding] Completed.`);
                // Replace old shards
                gateway.shards = new Collection(gateway.resharding.shards);
                // Clear our collections and keep only one reference to the shards, the one in gateway.shards
                gateway.resharding.shards.clear();
                gateway.resharding.pendingShards.clear();
            }
        },
        calculateTotalShards () {
            // Bots under 100k servers do not have access to LBS.
            if (gateway.totalShards < 100) {
                gateway.logger.debug(`[Gateway] Calculating total shards: ${gateway.totalShards}`);
                return gateway.totalShards;
            }
            gateway.logger.debug(`[Gateway] Calculating total shards`, gateway.totalShards, gateway.connection.sessionStartLimit.maxConcurrency);
            // Calculate a multiple of `maxConcurrency` which can be used to connect to the gateway.
            return Math.ceil(gateway.totalShards / // If `maxConcurrency` is 1, we can safely use 16 to get `totalShards` to be in a multiple of 16 so that we can prepare bots with 100k servers for LBS.
            (gateway.connection.sessionStartLimit.maxConcurrency === 1 ? 16 : gateway.connection.sessionStartLimit.maxConcurrency)) * (gateway.connection.sessionStartLimit.maxConcurrency === 1 ? 16 : gateway.connection.sessionStartLimit.maxConcurrency);
        },
        calculateWorkerId (shardId) {
            const workerId = Math.min(shardId % gateway.shardsPerWorker, gateway.totalWorkers - 1);
            gateway.logger.debug(`[Gateway] Calculating workerId: Shard: ${shardId} -> Worker: ${workerId} -> Per Worker: ${gateway.shardsPerWorker} -> Total: ${gateway.totalWorkers}`);
            return workerId;
        },
        prepareBuckets () {
            for(let i = 0; i < gateway.connection.sessionStartLimit.maxConcurrency; ++i){
                gateway.logger.debug(`[Gateway] Preparing buckets for concurrency: ${i}`);
                gateway.buckets.set(i, {
                    workers: [],
                    identifyRequests: []
                });
            }
            // ORGANIZE ALL SHARDS INTO THEIR OWN BUCKETS
            for(let shardId = gateway.firstShardId; shardId <= gateway.lastShardId; ++shardId){
                gateway.logger.debug(`[Gateway] Preparing buckets for shard: ${shardId}`);
                if (shardId >= gateway.totalShards) {
                    throw new Error(`Shard (id: ${shardId}) is bigger or equal to the used amount of used shards which is ${gateway.totalShards}`);
                }
                const bucketId = shardId % gateway.connection.sessionStartLimit.maxConcurrency;
                const bucket = gateway.buckets.get(bucketId);
                if (!bucket) {
                    throw new Error(`Shard (id: ${shardId}) got assigned to an illegal bucket id: ${bucketId}, expected a bucket id between 0 and ${gateway.connection.sessionStartLimit.maxConcurrency - 1}`);
                }
                // FIND A QUEUE IN THIS BUCKET THAT HAS SPACE
                // const worker = bucket.workers.find((w) => w.queue.length < gateway.shardsPerWorker);
                const workerId = gateway.calculateWorkerId(shardId);
                const worker = bucket.workers.find((w)=>w.id === workerId);
                if (worker) {
                    // IF THE QUEUE HAS SPACE JUST ADD IT TO THIS QUEUE
                    worker.queue.push(shardId);
                } else {
                    bucket.workers.push({
                        id: workerId,
                        queue: [
                            shardId
                        ]
                    });
                }
            }
            for (const bucket of gateway.buckets.values()){
                for (const worker of bucket.workers.values()){
                    worker.queue = worker.queue.sort((a, b)=>a - b);
                }
            }
        },
        async spawnShards () {
            // PREPARES ALL SHARDS IN SPECIFIC BUCKETS
            gateway.prepareBuckets();
            // Prefer concurrency of forEach instead of forof
            await Promise.all([
                ...gateway.buckets.entries()
            ].map(async ([bucketId, bucket])=>{
                for (const worker of bucket.workers){
                    for (const shardId of worker.queue){
                        await gateway.tellWorkerToIdentify(worker.id, shardId, bucketId);
                    }
                }
            }));
            // Check and reshard automatically if auto resharding is enabled.
            if (gateway.resharding.enabled && gateway.resharding.checkInterval !== -1) {
                // It is better to ensure there is always only one
                clearInterval(gateway.resharding.checkIntervalId);
                if (!gateway.resharding.getSessionInfo) {
                    gateway.resharding.enabled = false;
                    gateway.logger.warn("[Resharding] Resharding is enabled but 'resharding.getSessionInfo()' was not provided. Disabling resharding.");
                    return;
                }
                gateway.resharding.checkIntervalId = setInterval(async ()=>{
                    const reshardingInfo = await gateway.resharding.checkIfReshardingIsNeeded();
                    if (reshardingInfo.needed && reshardingInfo.info) await gateway.resharding.reshard(reshardingInfo.info);
                }, gateway.resharding.checkInterval);
            }
        },
        async shutdown (code, reason, clearReshardingInterval = true) {
            if (clearReshardingInterval) clearInterval(gateway.resharding.checkIntervalId);
            await Promise.all(Array.from(gateway.shards.values()).map((shard)=>shard.close(code, reason)));
        },
        async sendPayload (shardId, payload) {
            const shard = gateway.shards.get(shardId);
            if (!shard) {
                throw new Error(`Shard (id: ${shardId} not found`);
            }
            await shard.send(payload);
        },
        async tellWorkerToIdentify (workerId, shardId, bucketId) {
            gateway.logger.debug(`[Gateway] Tell worker to identify (${workerId}, ${shardId}, ${bucketId})`);
            await gateway.identify(shardId);
        },
        async identify (shardId) {
            let shard = this.shards.get(shardId);
            gateway.logger.debug(`[Gateway] Identifying ${shard ? 'existing' : 'new'} shard (${shardId})`);
            if (!shard) {
                shard = new Shard({
                    id: shardId,
                    connection: {
                        compress: this.compress,
                        transportCompression: gateway.transportCompression,
                        intents: this.intents,
                        properties: this.properties,
                        token: this.token,
                        totalShards: this.totalShards,
                        url: this.url,
                        version: this.version
                    },
                    events: options.events ?? {},
                    logger: this.logger,
                    requestIdentify: async ()=>{
                        await gateway.identify(shardId);
                    },
                    shardIsReady: async ()=>{
                        gateway.logger.debug(`[Shard] Shard #${shardId} is ready`);
                        await delay(gateway.spawnShardDelay);
                        gateway.logger.debug(`[Shard] Resolving shard identify request`);
                        gateway.buckets.get(shardId % gateway.connection.sessionStartLimit.maxConcurrency).identifyRequests.shift()?.();
                    },
                    makePresence: gateway.makePresence
                });
                if (this.preferSnakeCase) {
                    shard.forwardToBot = async (payload)=>{
                        shard.events.message?.(shard, payload);
                    };
                }
                this.shards.set(shardId, shard);
            }
            const bucket = gateway.buckets.get(shardId % gateway.connection.sessionStartLimit.maxConcurrency);
            if (!bucket) return;
            return await new Promise((resolve)=>{
                // Mark that we are making an identify request so another is not made.
                bucket.identifyRequests.push(resolve);
                gateway.logger.debug(`[Gateway] Identifying Shard #${shardId}.`);
                // This will trigger identify and when READY is received it will resolve the above request.
                shard?.identify();
            });
        },
        async kill (shardId) {
            const shard = this.shards.get(shardId);
            if (!shard) {
                return gateway.logger.debug(`[Gateway] A kill for Shard #${shardId} was requested, but the shard could not be found`);
            }
            gateway.logger.debug(`[Gateway] Killing Shard #${shardId}`);
            this.shards.delete(shardId);
            await shard.shutdown();
        },
        async requestIdentify (_shardId) {
            gateway.logger.debug(`[Gateway] Requesting identify`);
        },
        // Helpers methods below this
        calculateShardId (guildId, totalShards) {
            // If none is provided, use the total shards number from gateway object.
            if (!totalShards) totalShards = gateway.totalShards;
            // If it is only 1 shard, it will always be shard id 0
            if (totalShards === 1) {
                gateway.logger.debug(`[Gateway] calculateShardId (1 shard)`);
                return 0;
            }
            gateway.logger.debug(`[Gateway] calculateShardId (guildId: ${guildId}, totalShards: ${totalShards})`);
            return Number((BigInt(guildId) >> 22n) % BigInt(totalShards));
        },
        async joinVoiceChannel (guildId, channelId, options) {
            const shardId = gateway.calculateShardId(guildId);
            gateway.logger.debug(`[Gateway] joinVoiceChannel guildId: ${guildId} channelId: ${channelId}`);
            await gateway.sendPayload(shardId, {
                op: GatewayOpcodes.VoiceStateUpdate,
                d: {
                    guild_id: guildId.toString(),
                    channel_id: channelId.toString(),
                    self_mute: options?.selfMute ?? false,
                    self_deaf: options?.selfDeaf ?? true
                }
            });
        },
        async editBotStatus (data) {
            gateway.logger.debug(`[Gateway] editBotStatus data: ${JSON.stringify(data)}`);
            await Promise.all([
                ...gateway.shards.values()
            ].map(async (shard)=>{
                gateway.editShardStatus(shard.id, data);
            }));
        },
        async editShardStatus (shardId, data) {
            gateway.logger.debug(`[Gateway] editShardStatus shardId: ${shardId} -> data: ${JSON.stringify(data)}`);
            await gateway.sendPayload(shardId, {
                op: GatewayOpcodes.PresenceUpdate,
                d: {
                    since: null,
                    afk: false,
                    activities: data.activities,
                    status: data.status
                }
            });
        },
        async requestMembers (guildId, options) {
            const shardId = gateway.calculateShardId(guildId);
            if (gateway.intents && (!options?.limit || options.limit > 1) && !(gateway.intents & GatewayIntents.GuildMembers)) throw new Error('Cannot fetch more then 1 member without the GUILD_MEMBERS intent');
            gateway.logger.debug(`[Gateway] requestMembers guildId: ${guildId} -> data: ${JSON.stringify(options)}`);
            if (options?.userIds?.length) {
                gateway.logger.debug(`[Gateway] requestMembers guildId: ${guildId} -> setting user limit based on userIds length: ${options.userIds.length}`);
                options.limit = options.userIds.length;
            }
            if (!options?.nonce) {
                let nonce = '';
                while(!nonce || gateway.cache.requestMembers.pending.has(nonce)){
                    nonce = randomBytes(16).toString('hex');
                }
                options ??= {
                    limit: 0
                };
                options.nonce = nonce;
            }
            const members = !gateway.cache.requestMembers.enabled ? [] : new Promise((resolve, reject)=>{
                // Should never happen.
                if (!gateway.cache.requestMembers.enabled || !options?.nonce) {
                    reject(new Error("Can't request the members without the nonce or with the feature disabled."));
                    return;
                }
                gateway.cache.requestMembers.pending.set(options.nonce, {
                    nonce: options.nonce,
                    resolve,
                    members: []
                });
            });
            await gateway.sendPayload(shardId, {
                op: GatewayOpcodes.RequestGuildMembers,
                d: {
                    guild_id: guildId.toString(),
                    // If a query is provided use it, OR if a limit is NOT provided use ""
                    query: options?.query ?? (options?.limit ? undefined : ''),
                    limit: options?.limit ?? 0,
                    presences: options?.presences ?? false,
                    user_ids: options?.userIds?.map((id)=>id.toString()),
                    nonce: options?.nonce
                }
            });
            return await members;
        },
        async leaveVoiceChannel (guildId) {
            const shardId = gateway.calculateShardId(guildId);
            gateway.logger.debug(`[Gateway] leaveVoiceChannel guildId: ${guildId} Shard ${shardId}`);
            await gateway.sendPayload(shardId, {
                op: GatewayOpcodes.VoiceStateUpdate,
                d: {
                    guild_id: guildId.toString(),
                    channel_id: null,
                    self_mute: false,
                    self_deaf: false
                }
            });
        },
        async requestSoundboardSounds (guildIds) {
            /**
       * Discord will send the events for the guilds that are "under the shard" that sends the opcode.
       * For this reason we need to group the ids with the shard the calculateShardId method gives
       */ const map = new Map();
            for (const guildId of guildIds){
                const shardId = gateway.calculateShardId(guildId);
                const ids = map.get(shardId) ?? [];
                map.set(shardId, ids);
                ids.push(guildId);
            }
            await Promise.all([
                ...map.entries()
            ].map(([shardId, ids])=>gateway.sendPayload(shardId, {
                    op: GatewayOpcodes.RequestSoundboardSounds,
                    d: {
                        guild_ids: ids
                    }
                })));
        }
    };
    return gateway;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnbm9kZTpjcnlwdG8nXG5pbXBvcnQge1xuICB0eXBlIEF0TGVhc3RPbmUsXG4gIHR5cGUgQmlnU3RyaW5nLFxuICB0eXBlIENhbWVsaXplLFxuICB0eXBlIERpc2NvcmRHZXRHYXRld2F5Qm90LFxuICB0eXBlIERpc2NvcmRNZW1iZXJXaXRoVXNlcixcbiAgdHlwZSBEaXNjb3JkUmVhZHksXG4gIEdhdGV3YXlJbnRlbnRzLFxuICBHYXRld2F5T3Bjb2RlcyxcbiAgdHlwZSBSZXF1ZXN0R3VpbGRNZW1iZXJzLFxufSBmcm9tICdAZGlzY29yZGVuby90eXBlcydcbmltcG9ydCB7IENvbGxlY3Rpb24sIGRlbGF5LCBsb2dnZXIgfSBmcm9tICdAZGlzY29yZGVuby91dGlscydcbmltcG9ydCBTaGFyZCBmcm9tICcuL1NoYXJkLmpzJ1xuaW1wb3J0IHtcbiAgdHlwZSBCb3RTdGF0dXNVcGRhdGUsXG4gIHR5cGUgU2hhcmRFdmVudHMsXG4gIFNoYXJkU29ja2V0Q2xvc2VDb2RlcyxcbiAgdHlwZSBTaGFyZFNvY2tldFJlcXVlc3QsXG4gIHR5cGUgU3RhdHVzVXBkYXRlLFxuICB0eXBlIFRyYW5zcG9ydENvbXByZXNzaW9uLFxuICB0eXBlIFVwZGF0ZVZvaWNlU3RhdGUsXG59IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHYXRld2F5TWFuYWdlcihvcHRpb25zOiBDcmVhdGVHYXRld2F5TWFuYWdlck9wdGlvbnMpOiBHYXRld2F5TWFuYWdlciB7XG4gIGNvbnN0IGNvbm5lY3Rpb25PcHRpb25zID0gb3B0aW9ucy5jb25uZWN0aW9uID8/IHtcbiAgICB1cmw6ICd3c3M6Ly9nYXRld2F5LmRpc2NvcmQuZ2cnLFxuICAgIHNoYXJkczogMSxcbiAgICBzZXNzaW9uU3RhcnRMaW1pdDoge1xuICAgICAgbWF4Q29uY3VycmVuY3k6IDEsXG4gICAgICByZW1haW5pbmc6IDEwMDAsXG4gICAgICB0b3RhbDogMTAwMCxcbiAgICAgIHJlc2V0QWZ0ZXI6IDEwMDAgKiA2MCAqIDYwICogMjQsXG4gICAgfSxcbiAgfVxuXG4gIGNvbnN0IGdhdGV3YXk6IEdhdGV3YXlNYW5hZ2VyID0ge1xuICAgIGV2ZW50czogb3B0aW9ucy5ldmVudHMgPz8ge30sXG4gICAgY29tcHJlc3M6IG9wdGlvbnMuY29tcHJlc3MgPz8gZmFsc2UsXG4gICAgdHJhbnNwb3J0Q29tcHJlc3Npb246IG9wdGlvbnMudHJhbnNwb3J0Q29tcHJlc3Npb24gPz8gbnVsbCxcbiAgICBpbnRlbnRzOiBvcHRpb25zLmludGVudHMgPz8gMCxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBvczogb3B0aW9ucy5wcm9wZXJ0aWVzPy5vcyA/PyBwcm9jZXNzLnBsYXRmb3JtLFxuICAgICAgYnJvd3Nlcjogb3B0aW9ucy5wcm9wZXJ0aWVzPy5icm93c2VyID8/ICdEaXNjb3JkZW5vJyxcbiAgICAgIGRldmljZTogb3B0aW9ucy5wcm9wZXJ0aWVzPy5kZXZpY2UgPz8gJ0Rpc2NvcmRlbm8nLFxuICAgIH0sXG4gICAgdG9rZW46IG9wdGlvbnMudG9rZW4sXG4gICAgdXJsOiBvcHRpb25zLnVybCA/PyBjb25uZWN0aW9uT3B0aW9ucy51cmwgPz8gJ3dzczovL2dhdGV3YXkuZGlzY29yZC5nZycsXG4gICAgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uID8/IDEwLFxuICAgIGNvbm5lY3Rpb246IGNvbm5lY3Rpb25PcHRpb25zLFxuICAgIHRvdGFsU2hhcmRzOiBvcHRpb25zLnRvdGFsU2hhcmRzID8/IGNvbm5lY3Rpb25PcHRpb25zLnNoYXJkcyA/PyAxLFxuICAgIGxhc3RTaGFyZElkOiBvcHRpb25zLmxhc3RTaGFyZElkID8/IChvcHRpb25zLnRvdGFsU2hhcmRzID8gb3B0aW9ucy50b3RhbFNoYXJkcyAtIDEgOiBjb25uZWN0aW9uT3B0aW9ucyA/IGNvbm5lY3Rpb25PcHRpb25zLnNoYXJkcyAtIDEgOiAwKSxcbiAgICBmaXJzdFNoYXJkSWQ6IG9wdGlvbnMuZmlyc3RTaGFyZElkID8/IDAsXG4gICAgdG90YWxXb3JrZXJzOiBvcHRpb25zLnRvdGFsV29ya2VycyA/PyA0LFxuICAgIHNoYXJkc1Blcldvcmtlcjogb3B0aW9ucy5zaGFyZHNQZXJXb3JrZXIgPz8gMjUsXG4gICAgc3Bhd25TaGFyZERlbGF5OiBvcHRpb25zLnNwYXduU2hhcmREZWxheSA/PyA1MzAwLFxuICAgIHByZWZlclNuYWtlQ2FzZTogb3B0aW9ucy5wcmVmZXJTbmFrZUNhc2UgPz8gZmFsc2UsXG4gICAgc2hhcmRzOiBuZXcgTWFwKCksXG4gICAgYnVja2V0czogbmV3IE1hcCgpLFxuICAgIGNhY2hlOiB7XG4gICAgICByZXF1ZXN0TWVtYmVyczoge1xuICAgICAgICBlbmFibGVkOiBvcHRpb25zLmNhY2hlPy5yZXF1ZXN0TWVtYmVycz8uZW5hYmxlZCA/PyBmYWxzZSxcbiAgICAgICAgcGVuZGluZzogbmV3IENvbGxlY3Rpb24oKSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBsb2dnZXI6IG9wdGlvbnMubG9nZ2VyID8/IGxvZ2dlcixcbiAgICBtYWtlUHJlc2VuY2U6IG9wdGlvbnMubWFrZVByZXNlbmNlID8/ICgoKSA9PiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSksXG4gICAgcmVzaGFyZGluZzoge1xuICAgICAgZW5hYmxlZDogb3B0aW9ucy5yZXNoYXJkaW5nPy5lbmFibGVkID8/IHRydWUsXG4gICAgICBzaGFyZHNGdWxsUGVyY2VudGFnZTogb3B0aW9ucy5yZXNoYXJkaW5nPy5zaGFyZHNGdWxsUGVyY2VudGFnZSA/PyA4MCxcbiAgICAgIGNoZWNrSW50ZXJ2YWw6IG9wdGlvbnMucmVzaGFyZGluZz8uY2hlY2tJbnRlcnZhbCA/PyAyODgwMDAwMCwgLy8gOCBob3Vyc1xuICAgICAgc2hhcmRzOiBuZXcgQ29sbGVjdGlvbigpLFxuICAgICAgcGVuZGluZ1NoYXJkczogbmV3IENvbGxlY3Rpb24oKSxcbiAgICAgIGdldFNlc3Npb25JbmZvOiBvcHRpb25zLnJlc2hhcmRpbmc/LmdldFNlc3Npb25JbmZvLFxuICAgICAgdXBkYXRlR3VpbGRzU2hhcmRJZDogb3B0aW9ucy5yZXNoYXJkaW5nPy51cGRhdGVHdWlsZHNTaGFyZElkLFxuICAgICAgYXN5bmMgY2hlY2tJZlJlc2hhcmRpbmdJc05lZWRlZCgpIHtcbiAgICAgICAgZ2F0ZXdheS5sb2dnZXIuZGVidWcoJ1tSZXNoYXJkaW5nXSBDaGVja2luZyBpZiByZXNoYXJkaW5nIGlzIG5lZWRlZC4nKVxuXG4gICAgICAgIGlmICghZ2F0ZXdheS5yZXNoYXJkaW5nLmVuYWJsZWQpIHtcbiAgICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZygnW1Jlc2hhcmRpbmddIFJlc2hhcmRpbmcgaXMgZGlzYWJsZWQuJylcblxuICAgICAgICAgIHJldHVybiB7IG5lZWRlZDogZmFsc2UgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFnYXRld2F5LnJlc2hhcmRpbmcuZ2V0U2Vzc2lvbkluZm8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbUmVzaGFyZGluZ10gUmVzaGFyZGluZyBpcyBlbmFibGVkIGJ1dCBubyAncmVzaGFyZGluZy5nZXRTZXNzaW9uSW5mbygpJyBpcyBub3QgcHJvdmlkZWQuXCIpXG4gICAgICAgIH1cblxuICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZygnW1Jlc2hhcmRpbmddIFJlc2hhcmRpbmcgaXMgZW5hYmxlZC4nKVxuXG4gICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gYXdhaXQgZ2F0ZXdheS5yZXNoYXJkaW5nLmdldFNlc3Npb25JbmZvKClcblxuICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW1Jlc2hhcmRpbmddIFNlc3Npb24gaW5mbyByZXRyaWV2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoc2Vzc2lvbkluZm8pfWApXG5cbiAgICAgICAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2ggaWRlbnRpZnkgbGltaXRzIHRvIHRyeSByZXNoYXJkaW5nXG4gICAgICAgIGlmIChzZXNzaW9uSW5mby5zZXNzaW9uU3RhcnRMaW1pdC5yZW1haW5pbmcgPCBzZXNzaW9uSW5mby5zaGFyZHMpIHtcbiAgICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZygnW1Jlc2hhcmRpbmddIE5vdCBlbm91Z2ggc2Vzc2lvbiBzdGFydCBsaW1pdHMgbGVmdCB0byByZXNoYXJkLicpXG5cbiAgICAgICAgICByZXR1cm4geyBuZWVkZWQ6IGZhbHNlLCBpbmZvOiBzZXNzaW9uSW5mbyB9XG4gICAgICAgIH1cblxuICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZygnW1Jlc2hhcmRpbmddIEFibGUgdG8gcmVzaGFyZCwgY2hlY2tpbmcgd2hldGhlciBuZWNlc3Nhcnkgbm93LicpXG5cbiAgICAgICAgLy8gMjUwMCBpcyB0aGUgbWF4IGFtb3VudCBvZiBndWlsZHMgYSBzaW5nbGUgc2hhcmQgY2FuIGhhbmRsZVxuICAgICAgICAvLyAxMDAwIGlzIHRoZSBhbW91bnQgb2YgZ3VpbGRzIGRpc2NvcmQgdXNlcyB0byBkZXRlcm1pbmUgaG93IG1hbnkgc2hhcmRzIHRvIHJlY29tbWVuZC5cbiAgICAgICAgLy8gVGhpcyBhbGdvIGhlbHBzIGNoZWNrIGlmIHlvdXIgYm90IGhhcyBncm93biBlbm91Z2ggdG8gcmVzaGFyZC5cbiAgICAgICAgLy8gV2hpbGUgdGhpcyBpcyBpbXByZWNpc2UgYXMgZGlzY29yZCBjaGFuZ2VzIHRoZSByZWNvbW1lbmRlZCBudW1iZXIgb2Ygc2hhcmQgZXZlcnkgMTAwMCBndWlsZHMgaXQgaXMgZ29vZCBlbm91Z2hcbiAgICAgICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHN0b3JlIHRoZSBndWlsZCBjb3VudCBmb3IgZWFjaCBzaGFyZCBhbmQgcmVxdWlyZSB0aGUgR3VpbGRzIGludGVudCBmb3IgYEdVSUxEX0NSRUFURWAgYW5kIGBHVUlMRF9ERUxFVEVgIGV2ZW50c1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKHNlc3Npb25JbmZvLnNoYXJkcyAvICgoZ2F0ZXdheS50b3RhbFNoYXJkcyAqIDI1MDApIC8gMTAwMCkpICogMTAwXG5cbiAgICAgICAgLy8gTGVzcyB0aGFuIG5lY2Vzc2FyeSUgYmVpbmcgdXNlZCBzbyBkbyBub3RoaW5nXG4gICAgICAgIGlmIChwZXJjZW50YWdlIDwgZ2F0ZXdheS5yZXNoYXJkaW5nLnNoYXJkc0Z1bGxQZXJjZW50YWdlKSB7XG4gICAgICAgICAgZ2F0ZXdheS5sb2dnZXIuZGVidWcoJ1tSZXNoYXJkaW5nXSBSZXNoYXJkaW5nIG5vdCBuZWVkZWQuJylcblxuICAgICAgICAgIHJldHVybiB7IG5lZWRlZDogZmFsc2UsIGluZm86IHNlc3Npb25JbmZvIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdhdGV3YXkubG9nZ2VyLmluZm8oJ1tSZXNoYXJkaW5nXSBSZXNoYXJkaW5nIGlzIG5lZWRlZC4nKVxuXG4gICAgICAgIHJldHVybiB7IG5lZWRlZDogdHJ1ZSwgaW5mbzogc2Vzc2lvbkluZm8gfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHJlc2hhcmQoaW5mbykge1xuICAgICAgICBnYXRld2F5LmxvZ2dlci5pbmZvKGBbUmVzaGFyZGluZ10gU3RhcnRpbmcgdGhlIHJlc2hhcmQgcHJvY2Vzcy4gUHJldmlvdXMgdG90YWwgc2hhcmRzOiAke2dhdGV3YXkudG90YWxTaGFyZHN9YClcbiAgICAgICAgLy8gU2V0IHZhbHVlcyBvbiBnYXRld2F5XG4gICAgICAgIGdhdGV3YXkudG90YWxTaGFyZHMgPSBpbmZvLnNoYXJkc1xuICAgICAgICAvLyBIYW5kbGVzIHByZXBhcmluZyBtaWQgc2l6ZWQgYm90cyBmb3IgTEJTXG4gICAgICAgIGdhdGV3YXkudG90YWxTaGFyZHMgPSBnYXRld2F5LmNhbGN1bGF0ZVRvdGFsU2hhcmRzKClcbiAgICAgICAgLy8gU2V0IGZpcnN0IHNoYXJkIGlkIGlmIHByb3ZpZGVkIGluIGluZm9cbiAgICAgICAgaWYgKHR5cGVvZiBpbmZvLmZpcnN0U2hhcmRJZCA9PT0gJ251bWJlcicpIGdhdGV3YXkuZmlyc3RTaGFyZElkID0gaW5mby5maXJzdFNoYXJkSWRcbiAgICAgICAgLy8gU2V0IGxhc3Qgc2hhcmQgaWQgaWYgcHJvdmlkZWQgaW4gaW5mb1xuICAgICAgICBpZiAodHlwZW9mIGluZm8ubGFzdFNoYXJkSWQgPT09ICdudW1iZXInKSBnYXRld2F5Lmxhc3RTaGFyZElkID0gaW5mby5sYXN0U2hhcmRJZFxuICAgICAgICBnYXRld2F5LmxvZ2dlci5pbmZvKGBbUmVzaGFyZGluZ10gU3RhcnRpbmcgdGhlIHJlc2hhcmQgcHJvY2Vzcy4gTmV3IHRvdGFsIHNoYXJkczogJHtnYXRld2F5LnRvdGFsU2hhcmRzfWApXG5cbiAgICAgICAgLy8gUmVzZXR0aW5nIGJ1Y2tldHNcbiAgICAgICAgZ2F0ZXdheS5idWNrZXRzLmNsZWFyKClcbiAgICAgICAgLy8gUmVmaWxsaW5nIGJ1Y2tldHMgd2l0aCBuZXcgdmFsdWVzXG4gICAgICAgIGdhdGV3YXkucHJlcGFyZUJ1Y2tldHMoKVxuXG4gICAgICAgIC8vIFNQUkVBRCBUSElTIE9VVCBUTyBESUZGRVJFTlQgV09SS0VSUyBUTyBCRUdJTiBTVEFSVElORyBVUFxuICAgICAgICBnYXRld2F5LmJ1Y2tldHMuZm9yRWFjaChhc3luYyAoYnVja2V0LCBidWNrZXRJZCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIGJ1Y2tldC53b3JrZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNoYXJkSWQgb2Ygd29ya2VyLnF1ZXVlKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGdhdGV3YXkucmVzaGFyZGluZy50ZWxsV29ya2VyVG9QcmVwYXJlKHdvcmtlci5pZCwgc2hhcmRJZCwgYnVja2V0SWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHRlbGxXb3JrZXJUb1ByZXBhcmUod29ya2VySWQsIHNoYXJkSWQsIGJ1Y2tldElkKSB7XG4gICAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbUmVzaGFyZGluZ10gVGVsbGluZyB3b3JrZXIgdG8gcHJlcGFyZS4gV29ya2VyOiAke3dvcmtlcklkfSB8IFNoYXJkOiAke3NoYXJkSWR9IHwgQnVja2V0OiAke2J1Y2tldElkfS5gKVxuICAgICAgICBjb25zdCBzaGFyZCA9IG5ldyBTaGFyZCh7XG4gICAgICAgICAgaWQ6IHNoYXJkSWQsXG4gICAgICAgICAgY29ubmVjdGlvbjoge1xuICAgICAgICAgICAgY29tcHJlc3M6IGdhdGV3YXkuY29tcHJlc3MsXG4gICAgICAgICAgICB0cmFuc3BvcnRDb21wcmVzc2lvbjogZ2F0ZXdheS50cmFuc3BvcnRDb21wcmVzc2lvbiA/PyBudWxsLFxuICAgICAgICAgICAgaW50ZW50czogZ2F0ZXdheS5pbnRlbnRzLFxuICAgICAgICAgICAgcHJvcGVydGllczogZ2F0ZXdheS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdG9rZW46IGdhdGV3YXkudG9rZW4sXG4gICAgICAgICAgICB0b3RhbFNoYXJkczogZ2F0ZXdheS50b3RhbFNoYXJkcyxcbiAgICAgICAgICAgIHVybDogZ2F0ZXdheS51cmwsXG4gICAgICAgICAgICB2ZXJzaW9uOiBnYXRld2F5LnZlcnNpb24sXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBJZ25vcmUgZXZlbnRzIHVudGlsIHdlIGFyZSByZWFkeVxuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgYXN5bmMgbWVzc2FnZShfc2hhcmQsIHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgaWYgKHBheWxvYWQudCA9PT0gJ1JFQURZJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGdhdGV3YXkucmVzaGFyZGluZy51cGRhdGVHdWlsZHNTaGFyZElkPy4oXG4gICAgICAgICAgICAgICAgICAocGF5bG9hZC5kIGFzIERpc2NvcmRSZWFkeSkuZ3VpbGRzLm1hcCgoZykgPT4gZy5pZCksXG4gICAgICAgICAgICAgICAgICBzaGFyZElkLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxvZ2dlcjogZ2F0ZXdheS5sb2dnZXIsXG4gICAgICAgICAgcmVxdWVzdElkZW50aWZ5OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBnYXRld2F5LmlkZW50aWZ5KHNoYXJkSWQpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaGFyZElzUmVhZHk6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbU2hhcmRdIFNoYXJkICMke3NoYXJkSWR9IGlzIHJlYWR5YClcbiAgICAgICAgICAgIGF3YWl0IGRlbGF5KGdhdGV3YXkuc3Bhd25TaGFyZERlbGF5KVxuICAgICAgICAgICAgZ2F0ZXdheS5sb2dnZXIuZGVidWcoYFtTaGFyZF0gUmVzb2x2aW5nIHNoYXJkIGlkZW50aWZ5IHJlcXVlc3RgKVxuICAgICAgICAgICAgZ2F0ZXdheS5idWNrZXRzLmdldChzaGFyZElkICUgZ2F0ZXdheS5jb25uZWN0aW9uLnNlc3Npb25TdGFydExpbWl0Lm1heENvbmN1cnJlbmN5KSEuaWRlbnRpZnlSZXF1ZXN0cy5zaGlmdCgpPy4oKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWFrZVByZXNlbmNlOiBnYXRld2F5Lm1ha2VQcmVzZW5jZSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoZ2F0ZXdheS5wcmVmZXJTbmFrZUNhc2UpIHtcbiAgICAgICAgICBzaGFyZC5mb3J3YXJkVG9Cb3QgPSBhc3luYyAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgc2hhcmQuZXZlbnRzPy5tZXNzYWdlPy4oc2hhcmQsIHBheWxvYWQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2F0ZXdheS5yZXNoYXJkaW5nLnNoYXJkcy5zZXQoc2hhcmRJZCwgc2hhcmQpXG5cbiAgICAgICAgY29uc3QgYnVja2V0ID0gZ2F0ZXdheS5idWNrZXRzLmdldChzaGFyZElkICUgZ2F0ZXdheS5jb25uZWN0aW9uLnNlc3Npb25TdGFydExpbWl0Lm1heENvbmN1cnJlbmN5KVxuICAgICAgICBpZiAoIWJ1Y2tldCkgcmV0dXJuXG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgLy8gTWFyayB0aGF0IHdlIGFyZSBtYWtpbmcgYW4gaWRlbnRpZnkgcmVxdWVzdCBzbyBhbm90aGVyIGlzIG5vdCBtYWRlLlxuICAgICAgICAgIGJ1Y2tldC5pZGVudGlmeVJlcXVlc3RzLnB1c2gocmVzb2x2ZSlcbiAgICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW0dhdGV3YXldIElkZW50aWZ5aW5nIFNoYXJkICMke3NoYXJkSWR9LmApXG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgaWRlbnRpZnkgYW5kIHdoZW4gUkVBRFkgaXMgcmVjZWl2ZWQgaXQgd2lsbCByZXNvbHZlIHRoZSBhYm92ZSByZXF1ZXN0LlxuICAgICAgICAgIHNoYXJkPy5pZGVudGlmeSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVGVsbCB0aGUgbWFuYWdlciB0aGF0IHRoaXMgc2hhcmQgaXMgb25saW5lXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2F0ZXdheS5yZXNoYXJkaW5nLnNoYXJkSXNQZW5kaW5nKHNoYXJkKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgYXN5bmMgc2hhcmRJc1BlbmRpbmcoc2hhcmQpIHtcbiAgICAgICAgLy8gU2F2ZSB0aGlzIGluIHBlbmRpbmcgYXQgdGhlIG1vbWVudCwgdW50aWwgYWxsIHNoYXJkcyBhcmUgb25saW5lXG4gICAgICAgIGdhdGV3YXkucmVzaGFyZGluZy5wZW5kaW5nU2hhcmRzLnNldChzaGFyZC5pZCwgc2hhcmQpXG4gICAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbUmVzaGFyZGluZ10gU2hhcmQgIyR7c2hhcmQuaWR9IGlzIG5vdyBwZW5kaW5nLmApXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHNoYXJkcyBhcmUgbm93IG9ubGluZS5cbiAgICAgICAgaWYgKGdhdGV3YXkubGFzdFNoYXJkSWQgLSBnYXRld2F5LmZpcnN0U2hhcmRJZCA+PSBnYXRld2F5LnJlc2hhcmRpbmcucGVuZGluZ1NoYXJkcy5zaXplKSByZXR1cm5cblxuICAgICAgICBnYXRld2F5LmxvZ2dlci5pbmZvKGBbUmVzaGFyZGluZ10gQWxsIHNoYXJkcyBhcmUgbm93IG9ubGluZS5gKVxuXG4gICAgICAgIC8vIE5ldyBzaGFyZHMgc3RhcnQgcHJvY2Vzc2luZyBldmVudHNcbiAgICAgICAgZm9yIChjb25zdCBzaGFyZCBvZiBnYXRld2F5LnJlc2hhcmRpbmcuc2hhcmRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBldmVudCBpbiBvcHRpb25zLmV2ZW50cykge1xuICAgICAgICAgICAgc2hhcmQuZXZlbnRzW2V2ZW50IGFzIGtleW9mIFNoYXJkRXZlbnRzXSA9IG9wdGlvbnMuZXZlbnRzW2V2ZW50IGFzIGtleW9mIFNoYXJkRXZlbnRzXSBhcyAoLi4uYXJnczogdW5rbm93bltdKSA9PiB1bmtub3duXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT2xkIHNoYXJkcyBzdG9wIHByb2Nlc3NpbmcgZXZlbnRzXG4gICAgICAgIGZvciAoY29uc3Qgc2hhcmQgb2YgZ2F0ZXdheS5zaGFyZHMudmFsdWVzKCkpIHtcbiAgICAgICAgICBjb25zdCBvbGRIYW5kbGVyID0gc2hhcmQuZXZlbnRzLm1lc3NhZ2VcblxuICAgICAgICAgIC8vIENoYW5nZSB3aXRoIHNwcmVhZCBvcGVyYXRvciB0byBub3QgYWZmZWN0IG5ldyBzaGFyZHMsIGFzIGNoYW5naW5nIGFueXRoaW5nIG9uIHNoYXJkLmV2ZW50cyB3aWxsIGRpcmVjdGx5IGNoYW5nZSBvcHRpb25zLmV2ZW50cywgd2hpY2ggY2hhbmdlcyBuZXcgc2hhcmRzJyBldmVudHNcbiAgICAgICAgICBzaGFyZC5ldmVudHMgPSB7XG4gICAgICAgICAgICAuLi5zaGFyZC5ldmVudHMsXG4gICAgICAgICAgICBtZXNzYWdlOiBhc3luYyBmdW5jdGlvbiAoXywgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAvLyBNZW1iZXIgY2hlY2tzIG5lZWQgdG8gY29udGludWUgYnV0IG90aGVycyBjYW4gc3RvcFxuICAgICAgICAgICAgICBpZiAobWVzc2FnZS50ID09PSAnR1VJTERfTUVNQkVSU19DSFVOSycpIHtcbiAgICAgICAgICAgICAgICBvbGRIYW5kbGVyPy4oc2hhcmQsIG1lc3NhZ2UpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2F0ZXdheS5sb2dnZXIuaW5mbyhgW1Jlc2hhcmRpbmddIFNodXR0aW5nIGRvd24gb2xkIHNoYXJkcy5gKVxuICAgICAgICAvLyBDbG9zZSBvbGQgc2hhcmRzXG4gICAgICAgIGF3YWl0IGdhdGV3YXkuc2h1dGRvd24oU2hhcmRTb2NrZXRDbG9zZUNvZGVzLlJlc2hhcmRlZCwgJ1Jlc2hhcmRlZCEnLCBmYWxzZSlcblxuICAgICAgICBnYXRld2F5LmxvZ2dlci5pbmZvKGBbUmVzaGFyZGluZ10gQ29tcGxldGVkLmApXG5cbiAgICAgICAgLy8gUmVwbGFjZSBvbGQgc2hhcmRzXG4gICAgICAgIGdhdGV3YXkuc2hhcmRzID0gbmV3IENvbGxlY3Rpb24oZ2F0ZXdheS5yZXNoYXJkaW5nLnNoYXJkcylcblxuICAgICAgICAvLyBDbGVhciBvdXIgY29sbGVjdGlvbnMgYW5kIGtlZXAgb25seSBvbmUgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZHMsIHRoZSBvbmUgaW4gZ2F0ZXdheS5zaGFyZHNcbiAgICAgICAgZ2F0ZXdheS5yZXNoYXJkaW5nLnNoYXJkcy5jbGVhcigpXG4gICAgICAgIGdhdGV3YXkucmVzaGFyZGluZy5wZW5kaW5nU2hhcmRzLmNsZWFyKClcbiAgICAgIH0sXG4gICAgfSxcblxuICAgIGNhbGN1bGF0ZVRvdGFsU2hhcmRzKCkge1xuICAgICAgLy8gQm90cyB1bmRlciAxMDBrIHNlcnZlcnMgZG8gbm90IGhhdmUgYWNjZXNzIHRvIExCUy5cbiAgICAgIGlmIChnYXRld2F5LnRvdGFsU2hhcmRzIDwgMTAwKSB7XG4gICAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbR2F0ZXdheV0gQ2FsY3VsYXRpbmcgdG90YWwgc2hhcmRzOiAke2dhdGV3YXkudG90YWxTaGFyZHN9YClcbiAgICAgICAgcmV0dXJuIGdhdGV3YXkudG90YWxTaGFyZHNcbiAgICAgIH1cblxuICAgICAgZ2F0ZXdheS5sb2dnZXIuZGVidWcoYFtHYXRld2F5XSBDYWxjdWxhdGluZyB0b3RhbCBzaGFyZHNgLCBnYXRld2F5LnRvdGFsU2hhcmRzLCBnYXRld2F5LmNvbm5lY3Rpb24uc2Vzc2lvblN0YXJ0TGltaXQubWF4Q29uY3VycmVuY3kpXG4gICAgICAvLyBDYWxjdWxhdGUgYSBtdWx0aXBsZSBvZiBgbWF4Q29uY3VycmVuY3lgIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNvbm5lY3QgdG8gdGhlIGdhdGV3YXkuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgZ2F0ZXdheS50b3RhbFNoYXJkcyAvXG4gICAgICAgICAgICAvLyBJZiBgbWF4Q29uY3VycmVuY3lgIGlzIDEsIHdlIGNhbiBzYWZlbHkgdXNlIDE2IHRvIGdldCBgdG90YWxTaGFyZHNgIHRvIGJlIGluIGEgbXVsdGlwbGUgb2YgMTYgc28gdGhhdCB3ZSBjYW4gcHJlcGFyZSBib3RzIHdpdGggMTAwayBzZXJ2ZXJzIGZvciBMQlMuXG4gICAgICAgICAgICAoZ2F0ZXdheS5jb25uZWN0aW9uLnNlc3Npb25TdGFydExpbWl0Lm1heENvbmN1cnJlbmN5ID09PSAxID8gMTYgOiBnYXRld2F5LmNvbm5lY3Rpb24uc2Vzc2lvblN0YXJ0TGltaXQubWF4Q29uY3VycmVuY3kpLFxuICAgICAgICApICogKGdhdGV3YXkuY29ubmVjdGlvbi5zZXNzaW9uU3RhcnRMaW1pdC5tYXhDb25jdXJyZW5jeSA9PT0gMSA/IDE2IDogZ2F0ZXdheS5jb25uZWN0aW9uLnNlc3Npb25TdGFydExpbWl0Lm1heENvbmN1cnJlbmN5KVxuICAgICAgKVxuICAgIH0sXG4gICAgY2FsY3VsYXRlV29ya2VySWQoc2hhcmRJZCkge1xuICAgICAgY29uc3Qgd29ya2VySWQgPSBNYXRoLm1pbihzaGFyZElkICUgZ2F0ZXdheS5zaGFyZHNQZXJXb3JrZXIsIGdhdGV3YXkudG90YWxXb3JrZXJzIC0gMSlcbiAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKFxuICAgICAgICBgW0dhdGV3YXldIENhbGN1bGF0aW5nIHdvcmtlcklkOiBTaGFyZDogJHtzaGFyZElkfSAtPiBXb3JrZXI6ICR7d29ya2VySWR9IC0+IFBlciBXb3JrZXI6ICR7Z2F0ZXdheS5zaGFyZHNQZXJXb3JrZXJ9IC0+IFRvdGFsOiAke2dhdGV3YXkudG90YWxXb3JrZXJzfWAsXG4gICAgICApXG4gICAgICByZXR1cm4gd29ya2VySWRcbiAgICB9LFxuICAgIHByZXBhcmVCdWNrZXRzKCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYXRld2F5LmNvbm5lY3Rpb24uc2Vzc2lvblN0YXJ0TGltaXQubWF4Q29uY3VycmVuY3k7ICsraSkge1xuICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW0dhdGV3YXldIFByZXBhcmluZyBidWNrZXRzIGZvciBjb25jdXJyZW5jeTogJHtpfWApXG4gICAgICAgIGdhdGV3YXkuYnVja2V0cy5zZXQoaSwge1xuICAgICAgICAgIHdvcmtlcnM6IFtdLFxuICAgICAgICAgIGlkZW50aWZ5UmVxdWVzdHM6IFtdLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBPUkdBTklaRSBBTEwgU0hBUkRTIElOVE8gVEhFSVIgT1dOIEJVQ0tFVFNcbiAgICAgIGZvciAobGV0IHNoYXJkSWQgPSBnYXRld2F5LmZpcnN0U2hhcmRJZDsgc2hhcmRJZCA8PSBnYXRld2F5Lmxhc3RTaGFyZElkOyArK3NoYXJkSWQpIHtcbiAgICAgICAgZ2F0ZXdheS5sb2dnZXIuZGVidWcoYFtHYXRld2F5XSBQcmVwYXJpbmcgYnVja2V0cyBmb3Igc2hhcmQ6ICR7c2hhcmRJZH1gKVxuICAgICAgICBpZiAoc2hhcmRJZCA+PSBnYXRld2F5LnRvdGFsU2hhcmRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaGFyZCAoaWQ6ICR7c2hhcmRJZH0pIGlzIGJpZ2dlciBvciBlcXVhbCB0byB0aGUgdXNlZCBhbW91bnQgb2YgdXNlZCBzaGFyZHMgd2hpY2ggaXMgJHtnYXRld2F5LnRvdGFsU2hhcmRzfWApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWNrZXRJZCA9IHNoYXJkSWQgJSBnYXRld2F5LmNvbm5lY3Rpb24uc2Vzc2lvblN0YXJ0TGltaXQubWF4Q29uY3VycmVuY3lcbiAgICAgICAgY29uc3QgYnVja2V0ID0gZ2F0ZXdheS5idWNrZXRzLmdldChidWNrZXRJZClcbiAgICAgICAgaWYgKCFidWNrZXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgU2hhcmQgKGlkOiAke3NoYXJkSWR9KSBnb3QgYXNzaWduZWQgdG8gYW4gaWxsZWdhbCBidWNrZXQgaWQ6ICR7YnVja2V0SWR9LCBleHBlY3RlZCBhIGJ1Y2tldCBpZCBiZXR3ZWVuIDAgYW5kICR7XG4gICAgICAgICAgICAgIGdhdGV3YXkuY29ubmVjdGlvbi5zZXNzaW9uU3RhcnRMaW1pdC5tYXhDb25jdXJyZW5jeSAtIDFcbiAgICAgICAgICAgIH1gLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZJTkQgQSBRVUVVRSBJTiBUSElTIEJVQ0tFVCBUSEFUIEhBUyBTUEFDRVxuICAgICAgICAvLyBjb25zdCB3b3JrZXIgPSBidWNrZXQud29ya2Vycy5maW5kKCh3KSA9PiB3LnF1ZXVlLmxlbmd0aCA8IGdhdGV3YXkuc2hhcmRzUGVyV29ya2VyKTtcbiAgICAgICAgY29uc3Qgd29ya2VySWQgPSBnYXRld2F5LmNhbGN1bGF0ZVdvcmtlcklkKHNoYXJkSWQpXG4gICAgICAgIGNvbnN0IHdvcmtlciA9IGJ1Y2tldC53b3JrZXJzLmZpbmQoKHcpID0+IHcuaWQgPT09IHdvcmtlcklkKVxuICAgICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgICAgLy8gSUYgVEhFIFFVRVVFIEhBUyBTUEFDRSBKVVNUIEFERCBJVCBUTyBUSElTIFFVRVVFXG4gICAgICAgICAgd29ya2VyLnF1ZXVlLnB1c2goc2hhcmRJZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWNrZXQud29ya2Vycy5wdXNoKHsgaWQ6IHdvcmtlcklkLCBxdWV1ZTogW3NoYXJkSWRdIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBidWNrZXQgb2YgZ2F0ZXdheS5idWNrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIGJ1Y2tldC53b3JrZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgd29ya2VyLnF1ZXVlID0gd29ya2VyLnF1ZXVlLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBzcGF3blNoYXJkcygpIHtcbiAgICAgIC8vIFBSRVBBUkVTIEFMTCBTSEFSRFMgSU4gU1BFQ0lGSUMgQlVDS0VUU1xuICAgICAgZ2F0ZXdheS5wcmVwYXJlQnVja2V0cygpXG5cbiAgICAgIC8vIFByZWZlciBjb25jdXJyZW5jeSBvZiBmb3JFYWNoIGluc3RlYWQgb2YgZm9yb2ZcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBbLi4uZ2F0ZXdheS5idWNrZXRzLmVudHJpZXMoKV0ubWFwKGFzeW5jIChbYnVja2V0SWQsIGJ1Y2tldF0pID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHdvcmtlciBvZiBidWNrZXQud29ya2Vycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzaGFyZElkIG9mIHdvcmtlci5xdWV1ZSkge1xuICAgICAgICAgICAgICBhd2FpdCBnYXRld2F5LnRlbGxXb3JrZXJUb0lkZW50aWZ5KHdvcmtlci5pZCwgc2hhcmRJZCwgYnVja2V0SWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgIClcblxuICAgICAgLy8gQ2hlY2sgYW5kIHJlc2hhcmQgYXV0b21hdGljYWxseSBpZiBhdXRvIHJlc2hhcmRpbmcgaXMgZW5hYmxlZC5cbiAgICAgIGlmIChnYXRld2F5LnJlc2hhcmRpbmcuZW5hYmxlZCAmJiBnYXRld2F5LnJlc2hhcmRpbmcuY2hlY2tJbnRlcnZhbCAhPT0gLTEpIHtcbiAgICAgICAgLy8gSXQgaXMgYmV0dGVyIHRvIGVuc3VyZSB0aGVyZSBpcyBhbHdheXMgb25seSBvbmVcbiAgICAgICAgY2xlYXJJbnRlcnZhbChnYXRld2F5LnJlc2hhcmRpbmcuY2hlY2tJbnRlcnZhbElkKVxuXG4gICAgICAgIGlmICghZ2F0ZXdheS5yZXNoYXJkaW5nLmdldFNlc3Npb25JbmZvKSB7XG4gICAgICAgICAgZ2F0ZXdheS5yZXNoYXJkaW5nLmVuYWJsZWQgPSBmYWxzZVxuICAgICAgICAgIGdhdGV3YXkubG9nZ2VyLndhcm4oXCJbUmVzaGFyZGluZ10gUmVzaGFyZGluZyBpcyBlbmFibGVkIGJ1dCAncmVzaGFyZGluZy5nZXRTZXNzaW9uSW5mbygpJyB3YXMgbm90IHByb3ZpZGVkLiBEaXNhYmxpbmcgcmVzaGFyZGluZy5cIilcblxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgZ2F0ZXdheS5yZXNoYXJkaW5nLmNoZWNrSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXNoYXJkaW5nSW5mbyA9IGF3YWl0IGdhdGV3YXkucmVzaGFyZGluZy5jaGVja0lmUmVzaGFyZGluZ0lzTmVlZGVkKClcblxuICAgICAgICAgIGlmIChyZXNoYXJkaW5nSW5mby5uZWVkZWQgJiYgcmVzaGFyZGluZ0luZm8uaW5mbykgYXdhaXQgZ2F0ZXdheS5yZXNoYXJkaW5nLnJlc2hhcmQocmVzaGFyZGluZ0luZm8uaW5mbylcbiAgICAgICAgfSwgZ2F0ZXdheS5yZXNoYXJkaW5nLmNoZWNrSW50ZXJ2YWwpXG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBzaHV0ZG93bihjb2RlLCByZWFzb24sIGNsZWFyUmVzaGFyZGluZ0ludGVydmFsID0gdHJ1ZSkge1xuICAgICAgaWYgKGNsZWFyUmVzaGFyZGluZ0ludGVydmFsKSBjbGVhckludGVydmFsKGdhdGV3YXkucmVzaGFyZGluZy5jaGVja0ludGVydmFsSWQpXG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKEFycmF5LmZyb20oZ2F0ZXdheS5zaGFyZHMudmFsdWVzKCkpLm1hcCgoc2hhcmQpID0+IHNoYXJkLmNsb3NlKGNvZGUsIHJlYXNvbikpKVxuICAgIH0sXG4gICAgYXN5bmMgc2VuZFBheWxvYWQoc2hhcmRJZCwgcGF5bG9hZCkge1xuICAgICAgY29uc3Qgc2hhcmQgPSBnYXRld2F5LnNoYXJkcy5nZXQoc2hhcmRJZClcblxuICAgICAgaWYgKCFzaGFyZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNoYXJkIChpZDogJHtzaGFyZElkfSBub3QgZm91bmRgKVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBzaGFyZC5zZW5kKHBheWxvYWQpXG4gICAgfSxcbiAgICBhc3luYyB0ZWxsV29ya2VyVG9JZGVudGlmeSh3b3JrZXJJZCwgc2hhcmRJZCwgYnVja2V0SWQpIHtcbiAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbR2F0ZXdheV0gVGVsbCB3b3JrZXIgdG8gaWRlbnRpZnkgKCR7d29ya2VySWR9LCAke3NoYXJkSWR9LCAke2J1Y2tldElkfSlgKVxuICAgICAgYXdhaXQgZ2F0ZXdheS5pZGVudGlmeShzaGFyZElkKVxuICAgIH0sXG4gICAgYXN5bmMgaWRlbnRpZnkoc2hhcmRJZDogbnVtYmVyKSB7XG4gICAgICBsZXQgc2hhcmQgPSB0aGlzLnNoYXJkcy5nZXQoc2hhcmRJZClcbiAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbR2F0ZXdheV0gSWRlbnRpZnlpbmcgJHtzaGFyZCA/ICdleGlzdGluZycgOiAnbmV3J30gc2hhcmQgKCR7c2hhcmRJZH0pYClcblxuICAgICAgaWYgKCFzaGFyZCkge1xuICAgICAgICBzaGFyZCA9IG5ldyBTaGFyZCh7XG4gICAgICAgICAgaWQ6IHNoYXJkSWQsXG4gICAgICAgICAgY29ubmVjdGlvbjoge1xuICAgICAgICAgICAgY29tcHJlc3M6IHRoaXMuY29tcHJlc3MsXG4gICAgICAgICAgICB0cmFuc3BvcnRDb21wcmVzc2lvbjogZ2F0ZXdheS50cmFuc3BvcnRDb21wcmVzc2lvbixcbiAgICAgICAgICAgIGludGVudHM6IHRoaXMuaW50ZW50cyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHRoaXMucHJvcGVydGllcyxcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLnRva2VuLFxuICAgICAgICAgICAgdG90YWxTaGFyZHM6IHRoaXMudG90YWxTaGFyZHMsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXZlbnRzOiBvcHRpb25zLmV2ZW50cyA/PyB7fSxcbiAgICAgICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgICAgIHJlcXVlc3RJZGVudGlmeTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgZ2F0ZXdheS5pZGVudGlmeShzaGFyZElkKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2hhcmRJc1JlYWR5OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW1NoYXJkXSBTaGFyZCAjJHtzaGFyZElkfSBpcyByZWFkeWApXG4gICAgICAgICAgICBhd2FpdCBkZWxheShnYXRld2F5LnNwYXduU2hhcmREZWxheSlcbiAgICAgICAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbU2hhcmRdIFJlc29sdmluZyBzaGFyZCBpZGVudGlmeSByZXF1ZXN0YClcbiAgICAgICAgICAgIGdhdGV3YXkuYnVja2V0cy5nZXQoc2hhcmRJZCAlIGdhdGV3YXkuY29ubmVjdGlvbi5zZXNzaW9uU3RhcnRMaW1pdC5tYXhDb25jdXJyZW5jeSkhLmlkZW50aWZ5UmVxdWVzdHMuc2hpZnQoKT8uKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1ha2VQcmVzZW5jZTogZ2F0ZXdheS5tYWtlUHJlc2VuY2UsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHRoaXMucHJlZmVyU25ha2VDYXNlKSB7XG4gICAgICAgICAgc2hhcmQuZm9yd2FyZFRvQm90ID0gYXN5bmMgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIHNoYXJkIS5ldmVudHMubWVzc2FnZT8uKHNoYXJkISwgcGF5bG9hZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNoYXJkcy5zZXQoc2hhcmRJZCwgc2hhcmQpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1Y2tldCA9IGdhdGV3YXkuYnVja2V0cy5nZXQoc2hhcmRJZCAlIGdhdGV3YXkuY29ubmVjdGlvbi5zZXNzaW9uU3RhcnRMaW1pdC5tYXhDb25jdXJyZW5jeSlcbiAgICAgIGlmICghYnVja2V0KSByZXR1cm5cblxuICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIC8vIE1hcmsgdGhhdCB3ZSBhcmUgbWFraW5nIGFuIGlkZW50aWZ5IHJlcXVlc3Qgc28gYW5vdGhlciBpcyBub3QgbWFkZS5cbiAgICAgICAgYnVja2V0LmlkZW50aWZ5UmVxdWVzdHMucHVzaChyZXNvbHZlKVxuICAgICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW0dhdGV3YXldIElkZW50aWZ5aW5nIFNoYXJkICMke3NoYXJkSWR9LmApXG4gICAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGlkZW50aWZ5IGFuZCB3aGVuIFJFQURZIGlzIHJlY2VpdmVkIGl0IHdpbGwgcmVzb2x2ZSB0aGUgYWJvdmUgcmVxdWVzdC5cbiAgICAgICAgc2hhcmQ/LmlkZW50aWZ5KClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBhc3luYyBraWxsKHNoYXJkSWQ6IG51bWJlcikge1xuICAgICAgY29uc3Qgc2hhcmQgPSB0aGlzLnNoYXJkcy5nZXQoc2hhcmRJZClcbiAgICAgIGlmICghc2hhcmQpIHtcbiAgICAgICAgcmV0dXJuIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbR2F0ZXdheV0gQSBraWxsIGZvciBTaGFyZCAjJHtzaGFyZElkfSB3YXMgcmVxdWVzdGVkLCBidXQgdGhlIHNoYXJkIGNvdWxkIG5vdCBiZSBmb3VuZGApXG4gICAgICB9XG5cbiAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbR2F0ZXdheV0gS2lsbGluZyBTaGFyZCAjJHtzaGFyZElkfWApXG4gICAgICB0aGlzLnNoYXJkcy5kZWxldGUoc2hhcmRJZClcbiAgICAgIGF3YWl0IHNoYXJkLnNodXRkb3duKClcbiAgICB9LFxuICAgIGFzeW5jIHJlcXVlc3RJZGVudGlmeShfc2hhcmRJZDogbnVtYmVyKSB7XG4gICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW0dhdGV3YXldIFJlcXVlc3RpbmcgaWRlbnRpZnlgKVxuICAgIH0sXG5cbiAgICAvLyBIZWxwZXJzIG1ldGhvZHMgYmVsb3cgdGhpc1xuXG4gICAgY2FsY3VsYXRlU2hhcmRJZChndWlsZElkLCB0b3RhbFNoYXJkcykge1xuICAgICAgLy8gSWYgbm9uZSBpcyBwcm92aWRlZCwgdXNlIHRoZSB0b3RhbCBzaGFyZHMgbnVtYmVyIGZyb20gZ2F0ZXdheSBvYmplY3QuXG4gICAgICBpZiAoIXRvdGFsU2hhcmRzKSB0b3RhbFNoYXJkcyA9IGdhdGV3YXkudG90YWxTaGFyZHNcbiAgICAgIC8vIElmIGl0IGlzIG9ubHkgMSBzaGFyZCwgaXQgd2lsbCBhbHdheXMgYmUgc2hhcmQgaWQgMFxuICAgICAgaWYgKHRvdGFsU2hhcmRzID09PSAxKSB7XG4gICAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbR2F0ZXdheV0gY2FsY3VsYXRlU2hhcmRJZCAoMSBzaGFyZClgKVxuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuXG4gICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW0dhdGV3YXldIGNhbGN1bGF0ZVNoYXJkSWQgKGd1aWxkSWQ6ICR7Z3VpbGRJZH0sIHRvdGFsU2hhcmRzOiAke3RvdGFsU2hhcmRzfSlgKVxuICAgICAgcmV0dXJuIE51bWJlcigoQmlnSW50KGd1aWxkSWQpID4+IDIybikgJSBCaWdJbnQodG90YWxTaGFyZHMpKVxuICAgIH0sXG5cbiAgICBhc3luYyBqb2luVm9pY2VDaGFubmVsKGd1aWxkSWQsIGNoYW5uZWxJZCwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hhcmRJZCA9IGdhdGV3YXkuY2FsY3VsYXRlU2hhcmRJZChndWlsZElkKVxuXG4gICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW0dhdGV3YXldIGpvaW5Wb2ljZUNoYW5uZWwgZ3VpbGRJZDogJHtndWlsZElkfSBjaGFubmVsSWQ6ICR7Y2hhbm5lbElkfWApXG5cbiAgICAgIGF3YWl0IGdhdGV3YXkuc2VuZFBheWxvYWQoc2hhcmRJZCwge1xuICAgICAgICBvcDogR2F0ZXdheU9wY29kZXMuVm9pY2VTdGF0ZVVwZGF0ZSxcbiAgICAgICAgZDoge1xuICAgICAgICAgIGd1aWxkX2lkOiBndWlsZElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgY2hhbm5lbF9pZDogY2hhbm5lbElkLnRvU3RyaW5nKCksXG4gICAgICAgICAgc2VsZl9tdXRlOiBvcHRpb25zPy5zZWxmTXV0ZSA/PyBmYWxzZSxcbiAgICAgICAgICBzZWxmX2RlYWY6IG9wdGlvbnM/LnNlbGZEZWFmID8/IHRydWUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyBlZGl0Qm90U3RhdHVzKGRhdGEpIHtcbiAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbR2F0ZXdheV0gZWRpdEJvdFN0YXR1cyBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApXG5cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBbLi4uZ2F0ZXdheS5zaGFyZHMudmFsdWVzKCldLm1hcChhc3luYyAoc2hhcmQpID0+IHtcbiAgICAgICAgICBnYXRld2F5LmVkaXRTaGFyZFN0YXR1cyhzaGFyZC5pZCwgZGF0YSlcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfSxcblxuICAgIGFzeW5jIGVkaXRTaGFyZFN0YXR1cyhzaGFyZElkLCBkYXRhKSB7XG4gICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW0dhdGV3YXldIGVkaXRTaGFyZFN0YXR1cyBzaGFyZElkOiAke3NoYXJkSWR9IC0+IGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YClcblxuICAgICAgYXdhaXQgZ2F0ZXdheS5zZW5kUGF5bG9hZChzaGFyZElkLCB7XG4gICAgICAgIG9wOiBHYXRld2F5T3Bjb2Rlcy5QcmVzZW5jZVVwZGF0ZSxcbiAgICAgICAgZDoge1xuICAgICAgICAgIHNpbmNlOiBudWxsLFxuICAgICAgICAgIGFmazogZmFsc2UsXG4gICAgICAgICAgYWN0aXZpdGllczogZGF0YS5hY3Rpdml0aWVzLFxuICAgICAgICAgIHN0YXR1czogZGF0YS5zdGF0dXMsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0TWVtYmVycyhndWlsZElkLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGFyZElkID0gZ2F0ZXdheS5jYWxjdWxhdGVTaGFyZElkKGd1aWxkSWQpXG5cbiAgICAgIGlmIChnYXRld2F5LmludGVudHMgJiYgKCFvcHRpb25zPy5saW1pdCB8fCBvcHRpb25zLmxpbWl0ID4gMSkgJiYgIShnYXRld2F5LmludGVudHMgJiBHYXRld2F5SW50ZW50cy5HdWlsZE1lbWJlcnMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmZXRjaCBtb3JlIHRoZW4gMSBtZW1iZXIgd2l0aG91dCB0aGUgR1VJTERfTUVNQkVSUyBpbnRlbnQnKVxuXG4gICAgICBnYXRld2F5LmxvZ2dlci5kZWJ1ZyhgW0dhdGV3YXldIHJlcXVlc3RNZW1iZXJzIGd1aWxkSWQ6ICR7Z3VpbGRJZH0gLT4gZGF0YTogJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX1gKVxuXG4gICAgICBpZiAob3B0aW9ucz8udXNlcklkcz8ubGVuZ3RoKSB7XG4gICAgICAgIGdhdGV3YXkubG9nZ2VyLmRlYnVnKGBbR2F0ZXdheV0gcmVxdWVzdE1lbWJlcnMgZ3VpbGRJZDogJHtndWlsZElkfSAtPiBzZXR0aW5nIHVzZXIgbGltaXQgYmFzZWQgb24gdXNlcklkcyBsZW5ndGg6ICR7b3B0aW9ucy51c2VySWRzLmxlbmd0aH1gKVxuXG4gICAgICAgIG9wdGlvbnMubGltaXQgPSBvcHRpb25zLnVzZXJJZHMubGVuZ3RoXG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucz8ubm9uY2UpIHtcbiAgICAgICAgbGV0IG5vbmNlID0gJydcblxuICAgICAgICB3aGlsZSAoIW5vbmNlIHx8IGdhdGV3YXkuY2FjaGUucmVxdWVzdE1lbWJlcnMucGVuZGluZy5oYXMobm9uY2UpKSB7XG4gICAgICAgICAgbm9uY2UgPSByYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID8/PSB7IGxpbWl0OiAwIH1cbiAgICAgICAgb3B0aW9ucy5ub25jZSA9IG5vbmNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lbWJlcnMgPSAhZ2F0ZXdheS5jYWNoZS5yZXF1ZXN0TWVtYmVycy5lbmFibGVkXG4gICAgICAgID8gW11cbiAgICAgICAgOiBuZXcgUHJvbWlzZTxDYW1lbGl6ZTxEaXNjb3JkTWVtYmVyV2l0aFVzZXJbXT4+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gICAgICAgICAgICBpZiAoIWdhdGV3YXkuY2FjaGUucmVxdWVzdE1lbWJlcnMuZW5hYmxlZCB8fCAhb3B0aW9ucz8ubm9uY2UpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNhbid0IHJlcXVlc3QgdGhlIG1lbWJlcnMgd2l0aG91dCB0aGUgbm9uY2Ugb3Igd2l0aCB0aGUgZmVhdHVyZSBkaXNhYmxlZC5cIikpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnYXRld2F5LmNhY2hlLnJlcXVlc3RNZW1iZXJzLnBlbmRpbmcuc2V0KG9wdGlvbnMubm9uY2UsIHtcbiAgICAgICAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgIG1lbWJlcnM6IFtdLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuXG4gICAgICBhd2FpdCBnYXRld2F5LnNlbmRQYXlsb2FkKHNoYXJkSWQsIHtcbiAgICAgICAgb3A6IEdhdGV3YXlPcGNvZGVzLlJlcXVlc3RHdWlsZE1lbWJlcnMsXG4gICAgICAgIGQ6IHtcbiAgICAgICAgICBndWlsZF9pZDogZ3VpbGRJZC50b1N0cmluZygpLFxuICAgICAgICAgIC8vIElmIGEgcXVlcnkgaXMgcHJvdmlkZWQgdXNlIGl0LCBPUiBpZiBhIGxpbWl0IGlzIE5PVCBwcm92aWRlZCB1c2UgXCJcIlxuICAgICAgICAgIHF1ZXJ5OiBvcHRpb25zPy5xdWVyeSA/PyAob3B0aW9ucz8ubGltaXQgPyB1bmRlZmluZWQgOiAnJyksXG4gICAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0ID8/IDAsXG4gICAgICAgICAgcHJlc2VuY2VzOiBvcHRpb25zPy5wcmVzZW5jZXMgPz8gZmFsc2UsXG4gICAgICAgICAgdXNlcl9pZHM6IG9wdGlvbnM/LnVzZXJJZHM/Lm1hcCgoaWQpID0+IGlkLnRvU3RyaW5nKCkpLFxuICAgICAgICAgIG5vbmNlOiBvcHRpb25zPy5ub25jZSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBhd2FpdCBtZW1iZXJzXG4gICAgfSxcblxuICAgIGFzeW5jIGxlYXZlVm9pY2VDaGFubmVsKGd1aWxkSWQpIHtcbiAgICAgIGNvbnN0IHNoYXJkSWQgPSBnYXRld2F5LmNhbGN1bGF0ZVNoYXJkSWQoZ3VpbGRJZClcblxuICAgICAgZ2F0ZXdheS5sb2dnZXIuZGVidWcoYFtHYXRld2F5XSBsZWF2ZVZvaWNlQ2hhbm5lbCBndWlsZElkOiAke2d1aWxkSWR9IFNoYXJkICR7c2hhcmRJZH1gKVxuXG4gICAgICBhd2FpdCBnYXRld2F5LnNlbmRQYXlsb2FkKHNoYXJkSWQsIHtcbiAgICAgICAgb3A6IEdhdGV3YXlPcGNvZGVzLlZvaWNlU3RhdGVVcGRhdGUsXG4gICAgICAgIGQ6IHtcbiAgICAgICAgICBndWlsZF9pZDogZ3VpbGRJZC50b1N0cmluZygpLFxuICAgICAgICAgIGNoYW5uZWxfaWQ6IG51bGwsXG4gICAgICAgICAgc2VsZl9tdXRlOiBmYWxzZSxcbiAgICAgICAgICBzZWxmX2RlYWY6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdFNvdW5kYm9hcmRTb3VuZHMoZ3VpbGRJZHMpIHtcbiAgICAgIC8qKlxuICAgICAgICogRGlzY29yZCB3aWxsIHNlbmQgdGhlIGV2ZW50cyBmb3IgdGhlIGd1aWxkcyB0aGF0IGFyZSBcInVuZGVyIHRoZSBzaGFyZFwiIHRoYXQgc2VuZHMgdGhlIG9wY29kZS5cbiAgICAgICAqIEZvciB0aGlzIHJlYXNvbiB3ZSBuZWVkIHRvIGdyb3VwIHRoZSBpZHMgd2l0aCB0aGUgc2hhcmQgdGhlIGNhbGN1bGF0ZVNoYXJkSWQgbWV0aG9kIGdpdmVzXG4gICAgICAgKi9cblxuICAgICAgY29uc3QgbWFwID0gbmV3IE1hcDxudW1iZXIsIEJpZ1N0cmluZ1tdPigpXG5cbiAgICAgIGZvciAoY29uc3QgZ3VpbGRJZCBvZiBndWlsZElkcykge1xuICAgICAgICBjb25zdCBzaGFyZElkID0gZ2F0ZXdheS5jYWxjdWxhdGVTaGFyZElkKGd1aWxkSWQpXG5cbiAgICAgICAgY29uc3QgaWRzID0gbWFwLmdldChzaGFyZElkKSA/PyBbXVxuICAgICAgICBtYXAuc2V0KHNoYXJkSWQsIGlkcylcblxuICAgICAgICBpZHMucHVzaChndWlsZElkKVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgWy4uLm1hcC5lbnRyaWVzKCldLm1hcCgoW3NoYXJkSWQsIGlkc10pID0+XG4gICAgICAgICAgZ2F0ZXdheS5zZW5kUGF5bG9hZChzaGFyZElkLCB7XG4gICAgICAgICAgICBvcDogR2F0ZXdheU9wY29kZXMuUmVxdWVzdFNvdW5kYm9hcmRTb3VuZHMsXG4gICAgICAgICAgICBkOiB7XG4gICAgICAgICAgICAgIGd1aWxkX2lkczogaWRzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgKSxcbiAgICAgIClcbiAgICB9LFxuICB9XG5cbiAgcmV0dXJuIGdhdGV3YXlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVHYXRld2F5TWFuYWdlck9wdGlvbnMge1xuICAvKipcbiAgICogSWQgb2YgdGhlIGZpcnN0IFNoYXJkIHdoaWNoIHNob3VsZCBnZXQgY29udHJvbGxlZCBieSB0aGlzIG1hbmFnZXIuXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGZpcnN0U2hhcmRJZD86IG51bWJlclxuICAvKipcbiAgICogSWQgb2YgdGhlIGxhc3QgU2hhcmQgd2hpY2ggc2hvdWxkIGdldCBjb250cm9sbGVkIGJ5IHRoaXMgbWFuYWdlci5cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgbGFzdFNoYXJkSWQ/OiBudW1iZXJcbiAgLyoqXG4gICAqIERlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBzcGF3bmluZyBuZXh0IHNoYXJkLiBPUFRJTUFMIElTIEFCT1ZFIDUxMDAuIFlPVSBET04nVCBXQU5UIFRPIEhJVCBUSEUgUkFURSBMSU1JVCEhIVxuICAgKiBAZGVmYXVsdCA1MzAwXG4gICAqL1xuICBzcGF3blNoYXJkRGVsYXk/OiBudW1iZXJcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2VuZCB0aGUgZGlzY29yZCBwYWNrZXRzIGluIHNuYWtlIGNhc2UgZm9ybS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHByZWZlclNuYWtlQ2FzZT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFRvdGFsIGFtb3VudCBvZiBzaGFyZHMgeW91ciBib3QgdXNlcy4gVXNlZnVsIGZvciB6ZXJvLWRvd250aW1lIHVwZGF0ZXMgb3IgcmVzaGFyZGluZy5cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgdG90YWxTaGFyZHM/OiBudW1iZXJcbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2Ygc2hhcmRzIHRvIGxvYWQgcGVyIHdvcmtlci5cbiAgICogQGRlZmF1bHQgMjVcbiAgICovXG4gIHNoYXJkc1Blcldvcmtlcj86IG51bWJlclxuICAvKipcbiAgICogVGhlIHRvdGFsIGFtb3VudCBvZiB3b3JrZXJzIHRvIHVzZSBmb3IgeW91ciBib3QuXG4gICAqIEBkZWZhdWx0IDRcbiAgICovXG4gIHRvdGFsV29ya2Vycz86IG51bWJlclxuICAvKiogSW1wb3J0YW50IGRhdGEgd2hpY2ggaXMgdXNlZCBieSB0aGUgbWFuYWdlciB0byBjb25uZWN0IHNoYXJkcyB0byB0aGUgZ2F0ZXdheS4gKi9cbiAgY29ubmVjdGlvbj86IENhbWVsaXplPERpc2NvcmRHZXRHYXRld2F5Qm90PlxuICAvKiogV2hldGhlciBpbmNvbWluZyBwYXlsb2FkcyBhcmUgY29tcHJlc3NlZCB1c2luZyB6bGliLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY29tcHJlc3M/OiBib29sZWFuXG4gIC8qKiBXaGF0IHRyYW5zcG9ydCBjb21wcmVzc2lvbiBzaG91bGQgYmUgdXNlZCAqL1xuICB0cmFuc3BvcnRDb21wcmVzc2lvbj86IFRyYW5zcG9ydENvbXByZXNzaW9uIHwgbnVsbFxuICAvKiogVGhlIGNhbGN1bGF0ZWQgaW50ZW50IHZhbHVlIG9mIHRoZSBldmVudHMgd2hpY2ggdGhlIHNoYXJkIHNob3VsZCByZWNlaXZlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBpbnRlbnRzPzogbnVtYmVyXG4gIC8qKiBJZGVudGlmeSBwcm9wZXJ0aWVzIHRvIHVzZSAqL1xuICBwcm9wZXJ0aWVzPzoge1xuICAgIC8qKiBPcGVyYXRpbmcgc3lzdGVtIHRoZSBzaGFyZCBydW5zIG9uLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgXCJkYXJ3aW5cIiB8IFwibGludXhcIiB8IFwid2luZG93c1wiXG4gICAgICovXG4gICAgb3M6IHN0cmluZ1xuICAgIC8qKiBUaGUgXCJicm93c2VyXCIgd2hlcmUgdGhpcyBzaGFyZCBpcyBydW5uaW5nIG9uLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgXCJEaXNjb3JkZW5vXCJcbiAgICAgKi9cbiAgICBicm93c2VyOiBzdHJpbmdcbiAgICAvKiogVGhlIGRldmljZSBvbiB3aGljaCB0aGUgc2hhcmQgaXMgcnVubmluZy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IFwiRGlzY29yZGVub1wiXG4gICAgICovXG4gICAgZGV2aWNlOiBzdHJpbmdcbiAgfVxuICAvKiogQm90IHRva2VuIHdoaWNoIGlzIHVzZWQgdG8gY29ubmVjdCB0byBEaXNjb3JkICovXG4gIHRva2VuOiBzdHJpbmdcbiAgLyoqIFRoZSBVUkwgb2YgdGhlIGdhdGV3YXkgd2hpY2ggc2hvdWxkIGJlIGNvbm5lY3RlZCB0by5cbiAgICpcbiAgICogQGRlZmF1bHQgXCJ3c3M6Ly9nYXRld2F5LmRpc2NvcmQuZ2dcIlxuICAgKi9cbiAgdXJsPzogc3RyaW5nXG4gIC8qKiBUaGUgZ2F0ZXdheSB2ZXJzaW9uIHdoaWNoIHNob3VsZCBiZSB1c2VkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAxMFxuICAgKi9cbiAgdmVyc2lvbj86IG51bWJlclxuICAvKiogVGhlIGV2ZW50cyBoYW5kbGVycyAqL1xuICBldmVudHM/OiBTaGFyZEV2ZW50c1xuICAvKiogVGhpcyBtYW5hZ2VycyBjYWNoZSByZWxhdGVkIHNldHRpbmdzLiAqL1xuICBjYWNoZT86IHtcbiAgICByZXF1ZXN0TWVtYmVycz86IHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciBvciBub3QgcmVxdWVzdCBtZW1iZXIgcmVxdWVzdHMgc2hvdWxkIGJlIGNhY2hlZC5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIGVuYWJsZWQ/OiBib29sZWFuXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGUgbG9nZ2VyIHRoYXQgdGhlIGdhdGV3YXkgbWFuYWdlciB3aWxsIHVzZS5cbiAgICogQGRlZmF1bHQgbG9nZ2VyIC8vIFRoZSBsb2dnZXIgZXhwb3J0ZWQgYnkgYEBkaXNjb3JkZW5vL3V0aWxzYFxuICAgKi9cbiAgbG9nZ2VyPzogUGljazx0eXBlb2YgbG9nZ2VyLCAnZGVidWcnIHwgJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJyB8ICdmYXRhbCc+XG4gIC8qKlxuICAgKiBNYWtlIHRoZSBwcmVzZW5jZSBmb3Igd2hlbiB0aGUgYm90IGNvbm5lY3RzIHRvIHRoZSBnYXRld2F5XG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZWFjaCB0aW1lIGEgU2hhcmQgaXMgZ29pbmcgdG8gaWRlbnRpZnlcbiAgICovXG4gIG1ha2VQcmVzZW5jZT86ICgpID0+IFByb21pc2U8Qm90U3RhdHVzVXBkYXRlIHwgdW5kZWZpbmVkPlxuICAvKiogT3B0aW9ucyByZWxhdGVkIHRvIHJlc2hhcmRpbmcuICovXG4gIHJlc2hhcmRpbmc/OiB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgYXV0b21hdGVkIHJlc2hhcmRpbmcgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGVuYWJsZWQ6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBUaGUgJSBvZiBob3cgZnVsbCBhIHNoYXJkIGlzIHdoZW4gcmVzaGFyZGluZyBzaG91bGQgYmUgdHJpZ2dlcmVkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBXZSB1c2UgZGlzY29yZCByZWNvbW1lbmRlZCBzaGFyZCB2YWx1ZSB0byBnZXQgYW4gKiphcHByb3hpbWF0aW9uKiogb2YgdGhlIHNoYXJkIGZ1bGwgcGVyY2VudGFnZSB0byBjb21wYXJlIHdpdGggdGhpcyB2YWx1ZSBzbyB0aGUgYm90IG1heSBub3QgcmVzaGFyZCBhdCB0aGUgZXhhY3QgcGVyY2VudGFnZSBwcm92aWRlZCBidXQgbWF5IHJlc2hhcmQgd2hlbiBpdCBpcyBhIGJpdCBoaWdoZXIgdGhhbiB0aGUgcHJvdmlkZWQgcGVyY2VudGFnZS5cbiAgICAgKiBGb3IgYWNjdXJhdGUgY2FsY3VsYXRpb24sIHlvdSBtYXkgb3ZlcnJpZGUgdGhlIGBjaGVja0lmUmVzaGFyZGluZ0lzTmVlZGVkYCBmdW5jdGlvblxuICAgICAqXG4gICAgICogQGRlZmF1bHQgODAgYXMgaW4gODAlXG4gICAgICovXG4gICAgc2hhcmRzRnVsbFBlcmNlbnRhZ2U6IG51bWJlclxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMsIG9mIGhvdyBvZnRlbiB0byBjaGVjayB3aGV0aGVyIHJlc2hhcmRpbmcgaXMgbmVlZGVkIGFuZCByZXNoYXJkIGF1dG9tYXRpY2FsbHkuIFNldCB0byAtMSB0byBkaXNhYmxlIGF1dG8gcmVzaGFyZGluZy5cbiAgICAgKiBAZGVmYXVsdCAyODgwMDAwMCAoOCBob3VycylcbiAgICAgKi9cbiAgICBjaGVja0ludGVydmFsOiBudW1iZXJcbiAgICAvKiogSGFuZGxlciB0byBnZXQgc2hhcmQgY291bnQgYW5kIG90aGVyIHNlc3Npb24gaW5mby4gKi9cbiAgICBnZXRTZXNzaW9uSW5mbz86ICgpID0+IFByb21pc2U8Q2FtZWxpemU8RGlzY29yZEdldEdhdGV3YXlCb3Q+PlxuICAgIC8qKiBIYW5kbGVyIHRvIGVkaXQgdGhlIHNoYXJkIGlkIG9uIGFueSBjYWNoZWQgZ3VpbGRzLiAqL1xuICAgIHVwZGF0ZUd1aWxkc1NoYXJkSWQ/OiAoZ3VpbGRJZHM6IHN0cmluZ1tdLCBzaGFyZElkOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD5cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdhdGV3YXlNYW5hZ2VyIGV4dGVuZHMgUmVxdWlyZWQ8Q3JlYXRlR2F0ZXdheU1hbmFnZXJPcHRpb25zPiB7XG4gIC8qKiBUaGUgbWF4IGNvbmN1cnJlbmN5IGJ1Y2tldHMuIFRob3NlIHdpbGwgYmUgY3JlYXRlZCB3aGVuIHRoZSBgc3Bhd25TaGFyZHNgICh3aGljaCBjYWxscyBgcHJlcGFyZUJ1Y2tldHNgIHVuZGVyIHRoZSBob29kKSBmdW5jdGlvbiBnZXRzIGNhbGxlZC4gKi9cbiAgYnVja2V0czogTWFwPFxuICAgIG51bWJlcixcbiAgICB7XG4gICAgICB3b3JrZXJzOiBBcnJheTx7IGlkOiBudW1iZXI7IHF1ZXVlOiBudW1iZXJbXSB9PlxuICAgICAgLyoqIFJlcXVlc3RzIHRvIGlkZW50aWZ5IHNoYXJkcyBhcmUgbWFkZSBiYXNlZCBvbiB3aGV0aGVyIGl0IGlzIGF2YWlsYWJsZSB0byBiZSBtYWRlLiAqL1xuICAgICAgaWRlbnRpZnlSZXF1ZXN0czogQXJyYXk8KHZhbHVlOiB2b2lkIHwgUHJvbWlzZUxpa2U8dm9pZD4pID0+IHZvaWQ+XG4gICAgfVxuICA+XG4gIC8qKiBUaGUgc2hhcmRzIHRoYXQgYXJlIGNyZWF0ZWQuICovXG4gIHNoYXJkczogTWFwPG51bWJlciwgU2hhcmQ+XG4gIC8qKiBUaGUgbG9nZ2VyIGZvciB0aGUgZ2F0ZXdheSBtYW5hZ2VyLiAqL1xuICBsb2dnZXI6IFBpY2s8dHlwZW9mIGxvZ2dlciwgJ2RlYnVnJyB8ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcicgfCAnZmF0YWwnPlxuICAvKiogRXZlcnl0aGluZyByZWxhdGVkIHRvIHJlc2hhcmRpbmcuICovXG4gIHJlc2hhcmRpbmc6IENyZWF0ZUdhdGV3YXlNYW5hZ2VyT3B0aW9uc1sncmVzaGFyZGluZyddICYge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnZhbCBpZCBvZiB0aGUgY2hlY2sgaW50ZXJ2YWwuIFRoaXMgaXMgdXNlZCB0byBjbGVhciB0aGUgaW50ZXJ2YWwgd2hlbiB0aGUgbWFuYWdlciBpcyBzaHV0ZG93bi5cbiAgICAgKi9cbiAgICBjaGVja0ludGVydmFsSWQ/OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZFxuICAgIC8qKiBIb2xkcyB0aGUgc2hhcmRzIHRoYXQgcmVzaGFyZGluZyBoYXMgY3JlYXRlZC4gT25jZSByZXNoYXJkaW5nIGlzIGRvbmUsIHRoaXMgcmVwbGFjZXMgdGhlIGdhdGV3YXkuc2hhcmRzICovXG4gICAgc2hhcmRzOiBDb2xsZWN0aW9uPG51bWJlciwgU2hhcmQ+XG4gICAgLyoqIEhvbGRzIHRoZSBwZW5kaW5nIHNoYXJkcyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkIGFuZCBhcmUgcGVuZGluZyBhbGwgc2hhcmRzIGZpbmlzaCBsb2FkaW5nLiAqL1xuICAgIHBlbmRpbmdTaGFyZHM6IENvbGxlY3Rpb248bnVtYmVyLCBTaGFyZD5cbiAgICAvKiogSGFuZGxlciB0byBjaGVjayBpZiByZXNoYXJkaW5nIGlzIG5lY2Vzc2FyeS4gKi9cbiAgICBjaGVja0lmUmVzaGFyZGluZ0lzTmVlZGVkOiAoKSA9PiBQcm9taXNlPHsgbmVlZGVkOiBib29sZWFuOyBpbmZvPzogQ2FtZWxpemU8RGlzY29yZEdldEdhdGV3YXlCb3Q+IH0+XG4gICAgLyoqIEhhbmRsZXIgdG8gYmVnaW4gcmVzaGFyZGluZy4gKi9cbiAgICByZXNoYXJkOiAoaW5mbzogQ2FtZWxpemU8RGlzY29yZEdldEdhdGV3YXlCb3Q+ICYgeyBmaXJzdFNoYXJkSWQ/OiBudW1iZXI7IGxhc3RTaGFyZElkPzogbnVtYmVyIH0pID0+IFByb21pc2U8dm9pZD5cbiAgICAvKiogSGFuZGxlciB0byBjb21tdW5pY2F0ZSB0byBhIHdvcmtlciB0aGF0IGEgc2hhcmQgbmVlZHMgdG8gYmUgY3JlYXRlZC4gKi9cbiAgICB0ZWxsV29ya2VyVG9QcmVwYXJlOiAod29ya2VySWQ6IG51bWJlciwgc2hhcmRJZDogbnVtYmVyLCBidWNrZXRJZDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XG4gICAgLyoqIEhhbmRsZXIgdG8gYWxlcnQgdGhlIGdhdGV3YXkgdGhhdCBhIHNoYXJkKHJlc2hhcmRlZCkgaXMgb25saW5lLiBJdCBzaG91bGQgbm93IHdhaXQgZm9yIGFsbCBzaGFyZHMgdG8gYmUgcGVuZGluZyBiZWZvcmUgc2h1dHRpbmcgb2ZmIG9sZCBzaGFyZHMuICovXG4gICAgc2hhcmRJc1BlbmRpbmc6IChzaGFyZDogU2hhcmQpID0+IFByb21pc2U8dm9pZD5cbiAgfVxuICAvKiogRGV0ZXJtaW5lIG1heCBudW1iZXIgb2Ygc2hhcmRzIHRvIHVzZSBiYXNlZCB1cG9uIHRoZSBtYXggY29uY3VycmVuY3kuICovXG4gIGNhbGN1bGF0ZVRvdGFsU2hhcmRzOiAoKSA9PiBudW1iZXJcbiAgLyoqIERldGVybWluZSB0aGUgaWQgb2YgdGhlIHdvcmtlciB3aGljaCBpcyBoYW5kbGluZyBhIHNoYXJkLiAqL1xuICBjYWxjdWxhdGVXb3JrZXJJZDogKHNoYXJkSWQ6IG51bWJlcikgPT4gbnVtYmVyXG4gIC8qKiBQcmVwYXJlcyBhbGwgdGhlIGJ1Y2tldHMgdGhhdCBhcmUgYXZhaWxhYmxlIGZvciBpZGVudGlmeWluZyB0aGUgc2hhcmRzLiAqL1xuICBwcmVwYXJlQnVja2V0czogKCkgPT4gdm9pZFxuICAvKiogU3RhcnQgaWRlbnRpZnlpbmcgYWxsIHRoZSBzaGFyZHMuICovXG4gIHNwYXduU2hhcmRzOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIC8qKiBTaHV0ZG93biBhbGwgc2hhcmRzLiAqL1xuICBzaHV0ZG93bjogKGNvZGU6IG51bWJlciwgcmVhc29uOiBzdHJpbmcsIGNsZWFyUmVzaGFyZGluZ0ludGVydmFsPzogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPlxuICBzZW5kUGF5bG9hZDogKHNoYXJkSWQ6IG51bWJlciwgcGF5bG9hZDogU2hhcmRTb2NrZXRSZXF1ZXN0KSA9PiBQcm9taXNlPHZvaWQ+XG4gIC8qKiBBbGxvd3MgdXNlcnMgdG8gaG9vayBpbiBhbmQgY2hhbmdlIHRvIGNvbW11bmljYXRlIHRvIGRpZmZlcmVudCB3b3JrZXJzIGFjcm9zcyBkaWZmZXJlbnQgc2VydmVycyBvciBhbnl0aGluZyB0aGV5IGxpa2UuIEZvciBleGFtcGxlIHVzaW5nIHJlZGlzIHB1YnN1YiB0byB0YWxrIHRvIG90aGVyIHNlcnZlcnMuICovXG4gIHRlbGxXb3JrZXJUb0lkZW50aWZ5OiAod29ya2VySWQ6IG51bWJlciwgc2hhcmRJZDogbnVtYmVyLCBidWNrZXRJZDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XG4gIC8qKiBUZWxsIHRoZSBtYW5hZ2VyIHRvIGlkZW50aWZ5IGEgU2hhcmQuIElmIHRoaXMgU2hhcmQgaXMgbm90IGFscmVhZHkgbWFuYWdlZCB0aGlzIHdpbGwgYWxzbyBhZGQgdGhlIFNoYXJkIHRvIHRoZSBtYW5hZ2VyLiAqL1xuICBpZGVudGlmeTogKHNoYXJkSWQ6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPlxuICAvKiogS2lsbCBhIHNoYXJkLiBDbG9zZSBhIHNoYXJkcyBjb25uZWN0aW9uIHRvIERpc2NvcmQncyBnYXRld2F5IChpZiBhbnkpIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgbWFuYWdlci4gKi9cbiAga2lsbDogKHNoYXJkSWQ6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPlxuICAvKiogVGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgdGhlIGJ1Y2tldCBpcyBhbGxvd2VkIHRvIG1ha2UgdGhlIG5leHQgaWRlbnRpZnkgcmVxdWVzdC4gKi9cbiAgcmVxdWVzdElkZW50aWZ5OiAoc2hhcmRJZDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XG4gIC8qKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2Ygc2hhcmRzIGJhc2VkIG9uIHRoZSBndWlsZCBpZCBhbmQgdG90YWwgc2hhcmRzLiAqL1xuICBjYWxjdWxhdGVTaGFyZElkOiAoZ3VpbGRJZDogQmlnU3RyaW5nLCB0b3RhbFNoYXJkcz86IG51bWJlcikgPT4gbnVtYmVyXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0aGUgYm90IHVzZXIgdG8gYSB2b2ljZSBvciBzdGFnZSBjaGFubmVsLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNlbmRzIHRoZSBfVXBkYXRlIFZvaWNlIFN0YXRlXyBnYXRld2F5IGNvbW1hbmQgb3ZlciB0aGUgZ2F0ZXdheSBiZWhpbmQgdGhlIHNjZW5lcy5cbiAgICpcbiAgICogQHBhcmFtIGd1aWxkSWQgLSBUaGUgSUQgb2YgdGhlIGd1aWxkIHRoZSB2b2ljZSBjaGFubmVsIHRvIGxlYXZlIGlzIGluLlxuICAgKiBAcGFyYW0gY2hhbm5lbElkIC0gVGhlIElEIG9mIHRoZSBjaGFubmVsIHlvdSB3YW50IHRvIGpvaW4uXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFJlcXVpcmVzIHRoZSBgQ09OTkVDVGAgcGVybWlzc2lvbi5cbiAgICpcbiAgICogRmlyZXMgYSBfVm9pY2UgU3RhdGUgVXBkYXRlXyBnYXRld2F5IGV2ZW50LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2Rpc2NvcmQuY29tL2RldmVsb3BlcnMvZG9jcy90b3BpY3MvZ2F0ZXdheSN1cGRhdGUtdm9pY2Utc3RhdGV9XG4gICAqL1xuICBqb2luVm9pY2VDaGFubmVsOiAoZ3VpbGRJZDogQmlnU3RyaW5nLCBjaGFubmVsSWQ6IEJpZ1N0cmluZywgb3B0aW9ucz86IEF0TGVhc3RPbmU8T21pdDxVcGRhdGVWb2ljZVN0YXRlLCAnZ3VpbGRJZCcgfCAnY2hhbm5lbElkJz4+KSA9PiBQcm9taXNlPHZvaWQ+XG4gIC8qKlxuICAgKiBFZGl0cyB0aGUgYm90IHN0YXR1cyBpbiBhbGwgc2hhcmRzIHRoYXQgdGhpcyBnYXRld2F5IG1hbmFnZXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBzdGF0dXMgZGF0YSB0byBzZXQgdGhlIGJvdHMgc3RhdHVzIHRvLlxuICAgKiBAcmV0dXJucyBub3RoaW5nXG4gICAqL1xuICBlZGl0Qm90U3RhdHVzOiAoZGF0YTogU3RhdHVzVXBkYXRlKSA9PiBQcm9taXNlPHZvaWQ+XG4gIC8qKlxuICAgKiBFZGl0cyB0aGUgYm90J3Mgc3RhdHVzIG9uIG9uZSBzaGFyZC5cbiAgICpcbiAgICogQHBhcmFtIHNoYXJkSWQgVGhlIHNoYXJkIGlkIHRvIGVkaXQgdGhlIHN0YXR1cyBmb3IuXG4gICAqIEBwYXJhbSBkYXRhIFRoZSBzdGF0dXMgZGF0YSB0byBzZXQgdGhlIGJvdHMgc3RhdHVzIHRvLlxuICAgKiBAcmV0dXJucyBub3RoaW5nXG4gICAqL1xuICBlZGl0U2hhcmRTdGF0dXM6IChzaGFyZElkOiBudW1iZXIsIGRhdGE6IFN0YXR1c1VwZGF0ZSkgPT4gUHJvbWlzZTx2b2lkPlxuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgbGlzdCBvZiBtZW1iZXJzIGZvciBhIGd1aWxkIG92ZXIgdGhlIGdhdGV3YXkuIElmIGBnYXRld2F5LmNhY2hlLnJlcXVlc3RNZW1iZXJzLmVuYWJsZWRgIGlzIG5vdCBzZXQsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgYW5kIHlvdSdsbCBoYXZlIHRvIGhhbmRsZSB0aGUgYEdVSUxEX01FTUJFUlNfQ0hVTktgIGV2ZW50cyB5b3Vyc2VsZi5cbiAgICpcbiAgICogQHBhcmFtIGd1aWxkSWQgLSBUaGUgSUQgb2YgdGhlIGd1aWxkIHRvIGdldCB0aGUgbGlzdCBvZiBtZW1iZXJzIGZvci5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGZldGNoaW5nIG9mIHRoZSBtZW1iZXJzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiByZXF1ZXN0aW5nIHRoZSBlbnRpcmUgbWVtYmVyIGxpc3Q6XG4gICAqIC0gUmVxdWlyZXMgdGhlIGBHVUlMRF9NRU1CRVJTYCBpbnRlbnQuXG4gICAqXG4gICAqIElmIHJlcXVlc3RpbmcgcHJlc2VuY2VzICh7QGxpbmsgUmVxdWVzdEd1aWxkTWVtYmVycy5wcmVzZW5jZXMgfCBwcmVzZW5jZXN9IHNldCB0byBgdHJ1ZWApOlxuICAgKiAtIFJlcXVpcmVzIHRoZSBgR1VJTERfUFJFU0VOQ0VTYCBpbnRlbnQuXG4gICAqXG4gICAqIElmIHJlcXVlc3RpbmcgYSBwcmVmaXggKHtAbGluayBSZXF1ZXN0R3VpbGRNZW1iZXJzLnF1ZXJ5IHwgcXVlcnl9IG5vbi1gdW5kZWZpbmVkYCk6XG4gICAqIC0gUmV0dXJucyBhIG1heGltdW0gb2YgMTAwIG1lbWJlcnMuXG4gICAqXG4gICAqIElmIHJlcXVlc3RpbmcgYSB1c2VycyBieSBJRCAoe0BsaW5rIFJlcXVlc3RHdWlsZE1lbWJlcnMudXNlcklkcyB8IHVzZXJJZHN9IG5vbi1gdW5kZWZpbmVkYCk6XG4gICAqIC0gUmV0dXJucyBhIG1heGltdW0gb2YgMTAwIG1lbWJlcnMuXG4gICAqXG4gICAqIEZpcmVzIGEgX0d1aWxkIE1lbWJlcnMgQ2h1bmtfIGdhdGV3YXkgZXZlbnQgZm9yIGV2ZXJ5IDEwMDAgbWVtYmVycyBmZXRjaGVkLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2Rpc2NvcmQuY29tL2RldmVsb3BlcnMvZG9jcy90b3BpY3MvZ2F0ZXdheSNyZXF1ZXN0LWd1aWxkLW1lbWJlcnN9XG4gICAqL1xuICByZXF1ZXN0TWVtYmVyczogKGd1aWxkSWQ6IEJpZ1N0cmluZywgb3B0aW9ucz86IE9taXQ8UmVxdWVzdEd1aWxkTWVtYmVycywgJ2d1aWxkSWQnPikgPT4gUHJvbWlzZTxDYW1lbGl6ZTxEaXNjb3JkTWVtYmVyV2l0aFVzZXJbXT4+XG4gIC8qKlxuICAgKiBMZWF2ZXMgdGhlIHZvaWNlIGNoYW5uZWwgdGhlIGJvdCB1c2VyIGlzIGN1cnJlbnRseSBpbi5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBzZW5kcyB0aGUgX1VwZGF0ZSBWb2ljZSBTdGF0ZV8gZ2F0ZXdheSBjb21tYW5kIG92ZXIgdGhlIGdhdGV3YXkgYmVoaW5kIHRoZSBzY2VuZXMuXG4gICAqXG4gICAqIEBwYXJhbSBndWlsZElkIC0gVGhlIElEIG9mIHRoZSBndWlsZCB0aGUgdm9pY2UgY2hhbm5lbCB0byBsZWF2ZSBpcyBpbi5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogRmlyZXMgYSBfVm9pY2UgU3RhdGUgVXBkYXRlXyBnYXRld2F5IGV2ZW50LlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2Rpc2NvcmQuY29tL2RldmVsb3BlcnMvZG9jcy90b3BpY3MvZ2F0ZXdheSN1cGRhdGUtdm9pY2Utc3RhdGV9XG4gICAqL1xuICBsZWF2ZVZvaWNlQ2hhbm5lbDogKGd1aWxkSWQ6IEJpZ1N0cmluZykgPT4gUHJvbWlzZTx2b2lkPlxuICAvKipcbiAgICogVXNlZCB0byByZXF1ZXN0IHNvdW5kYm9hcmQgc291bmRzIGZvciBhIGxpc3Qgb2YgZ3VpbGRzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNlbmRzIG11bHRpcGxlIChzZWUgcmVtYXJrcykgX1JlcXVlc3QgU291bmRib2FyZCBTb3VuZHNfIGdhdGV3YXkgY29tbWFuZCBvdmVyIHRoZSBnYXRld2F5IGJlaGluZCB0aGUgc2NlbmVzLlxuICAgKlxuICAgKiBAcGFyYW0gZ3VpbGRJZHMgLSBUaGUgZ3VpbGRzIHRvIGdldCB0aGUgc291bmRzIGZyb21cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogRmlyZXMgYSBfU291bmRib2FyZCBTb3VuZHNfIGdhdGV3YXkgZXZlbnQuXG4gICAqXG4gICAqIOKaoO+4jyBEaXNjb3JkIHdpbGwgc2VuZCB0aGUgX1NvdW5kYm9hcmQgU291bmRzXyBmb3IgZWFjaCBvZiB0aGUgZ3VpbGQgaWRzXG4gICAqIGhvd2V2ZXIgeW91IG1heSBub3QgcmVjZWl2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZXZlbnRzIGFzIHRoZSBpZHMgcGFzc2VkIHRvIF9SZXF1ZXN0IFNvdW5kYm9hcmQgU291bmRzXyBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcbiAgICogLSBUaGUgYm90IGlzIG5vdCBpbiB0aGUgc2VydmVyIHByb3ZpZGVkXG4gICAqIC0gVGhlIHNoYXJkIHRoZSBtZXNzYWdlIGhhcyBiZWVuIHNlbnQgZnJvbSBkb2VzIG5vdCByZWNlaXZlIGV2ZW50cyBmb3IgdGhlIHNwZWNpZmllZCBndWlsZFxuICAgKlxuICAgKiBUbyBhdm9pZCB0aGlzIERpc2NvcmRlbm8gd2lsbCBhdXRvbWF0aWNhbGx5IHRyeSB0byBncm91cCB0aGUgaWRzIGJhc2VkIG9uIHdoYXQgc2hhcmQgdGhleSB3aWxsIG5lZWQgdG8gYmUgc2VudCwgYnV0IHRoaXMgaW52b2x2ZXMgc2VuZGluZyBtdWx0aXBsZSBtZXNzYWdlcyBpbiBtdWx0aXBsZSBzaGFyZHNcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kaXNjb3JkLmNvbS9kZXZlbG9wZXJzL2RvY3MvdG9waWNzL2dhdGV3YXktZXZlbnRzI3JlcXVlc3Qtc291bmRib2FyZC1zb3VuZHN9XG4gICAqL1xuICByZXF1ZXN0U291bmRib2FyZFNvdW5kczogKGd1aWxkSWRzOiBCaWdTdHJpbmdbXSkgPT4gUHJvbWlzZTx2b2lkPlxuICAvKiogVGhpcyBtYW5hZ2VycyBjYWNoZSByZWxhdGVkIHNldHRpbmdzLiAqL1xuICBjYWNoZToge1xuICAgIHJlcXVlc3RNZW1iZXJzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgb3Igbm90IHJlcXVlc3QgbWVtYmVyIHJlcXVlc3RzIHNob3VsZCBiZSBjYWNoZWQuXG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBlbmFibGVkOiBib29sZWFuXG4gICAgICAvKiogVGhlIHBlbmRpbmcgcmVxdWVzdHMuICovXG4gICAgICBwZW5kaW5nOiBDb2xsZWN0aW9uPHN0cmluZywgUmVxdWVzdE1lbWJlclJlcXVlc3Q+XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdE1lbWJlclJlcXVlc3Qge1xuICAvKiogVGhlIHVuaXF1ZSBub25jZSBmb3IgdGhpcyByZXF1ZXN0LiAqL1xuICBub25jZTogc3RyaW5nXG4gIC8qKiBUaGUgcmVzb2x2ZXIgaGFuZGxlciB0byBydW4gd2hlbiBhbGwgbWVtYmVycyBhcnJpdmUuICovXG4gIHJlc29sdmU6ICh2YWx1ZTogQ2FtZWxpemU8RGlzY29yZE1lbWJlcldpdGhVc2VyW10+IHwgUHJvbWlzZUxpa2U8Q2FtZWxpemU8RGlzY29yZE1lbWJlcldpdGhVc2VyW10+PikgPT4gdm9pZFxuICAvKiogVGhlIG1lbWJlcnMgdGhhdCBoYXZlIGFscmVhZHkgYXJyaXZlZCBmb3IgdGhpcyByZXF1ZXN0LiAqL1xuICBtZW1iZXJzOiBEaXNjb3JkTWVtYmVyV2l0aFVzZXJbXVxufVxuIl0sIm5hbWVzIjpbInJhbmRvbUJ5dGVzIiwiR2F0ZXdheUludGVudHMiLCJHYXRld2F5T3Bjb2RlcyIsIkNvbGxlY3Rpb24iLCJkZWxheSIsImxvZ2dlciIsIlNoYXJkIiwiU2hhcmRTb2NrZXRDbG9zZUNvZGVzIiwiY3JlYXRlR2F0ZXdheU1hbmFnZXIiLCJvcHRpb25zIiwiY29ubmVjdGlvbk9wdGlvbnMiLCJjb25uZWN0aW9uIiwidXJsIiwic2hhcmRzIiwic2Vzc2lvblN0YXJ0TGltaXQiLCJtYXhDb25jdXJyZW5jeSIsInJlbWFpbmluZyIsInRvdGFsIiwicmVzZXRBZnRlciIsImdhdGV3YXkiLCJldmVudHMiLCJjb21wcmVzcyIsInRyYW5zcG9ydENvbXByZXNzaW9uIiwiaW50ZW50cyIsInByb3BlcnRpZXMiLCJvcyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsImJyb3dzZXIiLCJkZXZpY2UiLCJ0b2tlbiIsInZlcnNpb24iLCJ0b3RhbFNoYXJkcyIsImxhc3RTaGFyZElkIiwiZmlyc3RTaGFyZElkIiwidG90YWxXb3JrZXJzIiwic2hhcmRzUGVyV29ya2VyIiwic3Bhd25TaGFyZERlbGF5IiwicHJlZmVyU25ha2VDYXNlIiwiTWFwIiwiYnVja2V0cyIsImNhY2hlIiwicmVxdWVzdE1lbWJlcnMiLCJlbmFibGVkIiwicGVuZGluZyIsIm1ha2VQcmVzZW5jZSIsIlByb21pc2UiLCJyZXNvbHZlIiwidW5kZWZpbmVkIiwicmVzaGFyZGluZyIsInNoYXJkc0Z1bGxQZXJjZW50YWdlIiwiY2hlY2tJbnRlcnZhbCIsInBlbmRpbmdTaGFyZHMiLCJnZXRTZXNzaW9uSW5mbyIsInVwZGF0ZUd1aWxkc1NoYXJkSWQiLCJjaGVja0lmUmVzaGFyZGluZ0lzTmVlZGVkIiwiZGVidWciLCJuZWVkZWQiLCJFcnJvciIsInNlc3Npb25JbmZvIiwiSlNPTiIsInN0cmluZ2lmeSIsImluZm8iLCJwZXJjZW50YWdlIiwicmVzaGFyZCIsImNhbGN1bGF0ZVRvdGFsU2hhcmRzIiwiY2xlYXIiLCJwcmVwYXJlQnVja2V0cyIsImZvckVhY2giLCJidWNrZXQiLCJidWNrZXRJZCIsIndvcmtlciIsIndvcmtlcnMiLCJzaGFyZElkIiwicXVldWUiLCJ0ZWxsV29ya2VyVG9QcmVwYXJlIiwiaWQiLCJ3b3JrZXJJZCIsInNoYXJkIiwibWVzc2FnZSIsIl9zaGFyZCIsInBheWxvYWQiLCJ0IiwiZCIsImd1aWxkcyIsIm1hcCIsImciLCJyZXF1ZXN0SWRlbnRpZnkiLCJpZGVudGlmeSIsInNoYXJkSXNSZWFkeSIsImdldCIsImlkZW50aWZ5UmVxdWVzdHMiLCJzaGlmdCIsImZvcndhcmRUb0JvdCIsInNldCIsInB1c2giLCJ0aGVuIiwic2hhcmRJc1BlbmRpbmciLCJzaXplIiwidmFsdWVzIiwiZXZlbnQiLCJvbGRIYW5kbGVyIiwiXyIsInNodXRkb3duIiwiUmVzaGFyZGVkIiwiTWF0aCIsImNlaWwiLCJjYWxjdWxhdGVXb3JrZXJJZCIsIm1pbiIsImkiLCJmaW5kIiwidyIsInNvcnQiLCJhIiwiYiIsInNwYXduU2hhcmRzIiwiYWxsIiwiZW50cmllcyIsInRlbGxXb3JrZXJUb0lkZW50aWZ5IiwiY2xlYXJJbnRlcnZhbCIsImNoZWNrSW50ZXJ2YWxJZCIsIndhcm4iLCJzZXRJbnRlcnZhbCIsInJlc2hhcmRpbmdJbmZvIiwiY29kZSIsInJlYXNvbiIsImNsZWFyUmVzaGFyZGluZ0ludGVydmFsIiwiQXJyYXkiLCJmcm9tIiwiY2xvc2UiLCJzZW5kUGF5bG9hZCIsInNlbmQiLCJraWxsIiwiZGVsZXRlIiwiX3NoYXJkSWQiLCJjYWxjdWxhdGVTaGFyZElkIiwiZ3VpbGRJZCIsIk51bWJlciIsIkJpZ0ludCIsImpvaW5Wb2ljZUNoYW5uZWwiLCJjaGFubmVsSWQiLCJvcCIsIlZvaWNlU3RhdGVVcGRhdGUiLCJndWlsZF9pZCIsInRvU3RyaW5nIiwiY2hhbm5lbF9pZCIsInNlbGZfbXV0ZSIsInNlbGZNdXRlIiwic2VsZl9kZWFmIiwic2VsZkRlYWYiLCJlZGl0Qm90U3RhdHVzIiwiZGF0YSIsImVkaXRTaGFyZFN0YXR1cyIsIlByZXNlbmNlVXBkYXRlIiwic2luY2UiLCJhZmsiLCJhY3Rpdml0aWVzIiwic3RhdHVzIiwibGltaXQiLCJHdWlsZE1lbWJlcnMiLCJ1c2VySWRzIiwibGVuZ3RoIiwibm9uY2UiLCJoYXMiLCJtZW1iZXJzIiwicmVqZWN0IiwiUmVxdWVzdEd1aWxkTWVtYmVycyIsInF1ZXJ5IiwicHJlc2VuY2VzIiwidXNlcl9pZHMiLCJsZWF2ZVZvaWNlQ2hhbm5lbCIsInJlcXVlc3RTb3VuZGJvYXJkU291bmRzIiwiZ3VpbGRJZHMiLCJpZHMiLCJSZXF1ZXN0U291bmRib2FyZFNvdW5kcyIsImd1aWxkX2lkcyJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBU0EsV0FBVyxRQUFRLGNBQWE7QUFDekMsU0FPRUMsY0FBYyxFQUNkQyxjQUFjLFFBRVQsb0JBQW1CO0FBQzFCLFNBQVNDLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLFFBQVEs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
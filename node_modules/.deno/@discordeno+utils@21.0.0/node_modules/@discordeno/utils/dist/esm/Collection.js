export class Collection extends Map {
    constructor(entries, options){
        super(entries ?? []);
        this.maxSize = options?.maxSize;
        if (!options?.sweeper) return;
        this.startSweeper(options.sweeper);
    }
    startSweeper(options) {
        if (this.sweeper?.intervalId) clearInterval(this.sweeper.intervalId);
        this.sweeper = options;
        this.sweeper.intervalId = setInterval(()=>{
            this.forEach((value, key)=>{
                if (!this.sweeper?.filter(value, key, options.bot)) return;
                this.delete(key);
                return key;
            });
        }, options.interval);
        return this.sweeper.intervalId;
    }
    stopSweeper() {
        return clearInterval(this.sweeper?.intervalId);
    }
    changeSweeperInterval(newInterval) {
        if (this.sweeper == null) return;
        this.startSweeper({
            filter: this.sweeper.filter,
            interval: newInterval
        });
    }
    changeSweeperFilter(newFilter) {
        if (this.sweeper == null) return;
        this.startSweeper({
            filter: newFilter,
            interval: this.sweeper.interval
        });
    }
    /** Add an item to the collection. Makes sure not to go above the maxSize. */ set(key, value) {
        // When this collection is maxSized make sure we can add first
        if ((this.maxSize !== undefined || this.maxSize === 0) && this.size >= this.maxSize) {
            return this;
        }
        return super.set(key, value);
    }
    /** Add an item to the collection, no matter what the maxSize is. */ forceSet(key, value) {
        return super.set(key, value);
    }
    /** Convert the collection to an array. */ array() {
        return [
            ...this.values()
        ];
    }
    /** Retrieve the value of the first element in this collection. */ first() {
        return this.values().next().value;
    }
    /** Retrieve the value of the last element in this collection. */ last() {
        return [
            ...this.values()
        ][this.size - 1];
    }
    /** Retrieve the value of a random element in this collection. */ random() {
        const array = [
            ...this.values()
        ];
        return array[Math.floor(Math.random() * array.length)];
    }
    /** Find a specific element in this collection. */ find(callback) {
        for (const key of this.keys()){
            const value = this.get(key);
            if (callback(value, key)) return value;
        }
    // If nothing matched
    }
    /** Find all elements in this collection that match the given pattern. */ filter(callback) {
        const relevant = new Collection();
        this.forEach((value, key)=>{
            if (callback(value, key)) relevant.set(key, value);
        });
        return relevant;
    }
    /** Converts the collection into an array by running a callback on all items in the collection. */ map(callback) {
        const results = [];
        for (const key of this.keys()){
            const value = this.get(key);
            results.push(callback(value, key));
        }
        return results;
    }
    /** Check if one of the items in the collection matches the pattern. */ some(callback) {
        for (const key of this.keys()){
            const value = this.get(key);
            if (callback(value, key)) return true;
        }
        return false;
    }
    /** Check if all of the items in the collection matches the pattern. */ every(callback) {
        for (const key of this.keys()){
            const value = this.get(key);
            if (!callback(value, key)) return false;
        }
        return true;
    }
    /** Runs a callback on all items in the collection, merging them into a single value. */ reduce(callback, initialValue) {
        let accumulator = initialValue;
        for (const key of this.keys()){
            const value = this.get(key);
            accumulator = callback(accumulator, value, key);
        }
        return accumulator;
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Db2xsZWN0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgUGxhY2VIb2xkZXJCb3Qge31cblxuZXhwb3J0IGNsYXNzIENvbGxlY3Rpb248SywgVj4gZXh0ZW5kcyBNYXA8SywgVj4ge1xuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIGl0ZW1zIGFsbG93ZWQgaW4gdGhpcyBjb2xsZWN0aW9uLiBUbyBkaXNhYmxlIGNhY2hlLCBzZXQgaXQgMCwgc2V0IHRvIHVuZGVmaW5lZCB0byBtYWtlIGl0IGluZmluaXRlLlxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIG1heFNpemU6IG51bWJlciB8IHVuZGVmaW5lZFxuICAvKiogSGFuZGxlciB0byByZW1vdmUgaXRlbXMgZnJvbSB0aGUgY29sbGVjdGlvbiBldmVyeSBzbyBvZnRlbi4gKi9cbiAgc3dlZXBlcjogKENvbGxlY3Rpb25Td2VlcGVyPEssIFY+ICYgeyBpbnRlcnZhbElkPzogTm9kZUpTLlRpbWVvdXQgfSkgfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3RvcihlbnRyaWVzPzogKFJlYWRvbmx5QXJyYXk8cmVhZG9ubHkgW0ssIFZdPiB8IG51bGwpIHwgTWFwPEssIFY+LCBvcHRpb25zPzogQ29sbGVjdGlvbk9wdGlvbnM8SywgVj4pIHtcbiAgICBzdXBlcihlbnRyaWVzID8/IFtdKVxuXG4gICAgdGhpcy5tYXhTaXplID0gb3B0aW9ucz8ubWF4U2l6ZVxuXG4gICAgaWYgKCFvcHRpb25zPy5zd2VlcGVyKSByZXR1cm5cblxuICAgIHRoaXMuc3RhcnRTd2VlcGVyKG9wdGlvbnMuc3dlZXBlcilcbiAgfVxuXG4gIHN0YXJ0U3dlZXBlcihvcHRpb25zOiBDb2xsZWN0aW9uU3dlZXBlcjxLLCBWPik6IE5vZGVKUy5UaW1lb3V0IHtcbiAgICBpZiAodGhpcy5zd2VlcGVyPy5pbnRlcnZhbElkKSBjbGVhckludGVydmFsKHRoaXMuc3dlZXBlci5pbnRlcnZhbElkKVxuXG4gICAgdGhpcy5zd2VlcGVyID0gb3B0aW9uc1xuICAgIHRoaXMuc3dlZXBlci5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5zd2VlcGVyPy5maWx0ZXIodmFsdWUsIGtleSwgb3B0aW9ucy5ib3QpKSByZXR1cm5cblxuICAgICAgICB0aGlzLmRlbGV0ZShrZXkpXG4gICAgICAgIHJldHVybiBrZXlcbiAgICAgIH0pXG4gICAgfSwgb3B0aW9ucy5pbnRlcnZhbClcblxuICAgIHJldHVybiB0aGlzLnN3ZWVwZXIuaW50ZXJ2YWxJZFxuICB9XG5cbiAgc3RvcFN3ZWVwZXIoKTogdm9pZCB7XG4gICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwodGhpcy5zd2VlcGVyPy5pbnRlcnZhbElkKVxuICB9XG5cbiAgY2hhbmdlU3dlZXBlckludGVydmFsKG5ld0ludGVydmFsOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zd2VlcGVyID09IG51bGwpIHJldHVyblxuXG4gICAgdGhpcy5zdGFydFN3ZWVwZXIoeyBmaWx0ZXI6IHRoaXMuc3dlZXBlci5maWx0ZXIsIGludGVydmFsOiBuZXdJbnRlcnZhbCB9KVxuICB9XG5cbiAgY2hhbmdlU3dlZXBlckZpbHRlcihuZXdGaWx0ZXI6ICh2YWx1ZTogViwga2V5OiBLLCBib3Q6IFBsYWNlSG9sZGVyQm90KSA9PiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3dlZXBlciA9PSBudWxsKSByZXR1cm5cblxuICAgIHRoaXMuc3RhcnRTd2VlcGVyKHsgZmlsdGVyOiBuZXdGaWx0ZXIsIGludGVydmFsOiB0aGlzLnN3ZWVwZXIuaW50ZXJ2YWwgfSlcbiAgfVxuXG4gIC8qKiBBZGQgYW4gaXRlbSB0byB0aGUgY29sbGVjdGlvbi4gTWFrZXMgc3VyZSBub3QgdG8gZ28gYWJvdmUgdGhlIG1heFNpemUuICovXG4gIHNldChrZXk6IEssIHZhbHVlOiBWKTogdGhpcyB7XG4gICAgLy8gV2hlbiB0aGlzIGNvbGxlY3Rpb24gaXMgbWF4U2l6ZWQgbWFrZSBzdXJlIHdlIGNhbiBhZGQgZmlyc3RcbiAgICBpZiAoKHRoaXMubWF4U2l6ZSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMubWF4U2l6ZSA9PT0gMCkgJiYgdGhpcy5zaXplID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuc2V0KGtleSwgdmFsdWUpXG4gIH1cblxuICAvKiogQWRkIGFuIGl0ZW0gdG8gdGhlIGNvbGxlY3Rpb24sIG5vIG1hdHRlciB3aGF0IHRoZSBtYXhTaXplIGlzLiAqL1xuICBmb3JjZVNldChrZXk6IEssIHZhbHVlOiBWKTogdGhpcyB7XG4gICAgcmV0dXJuIHN1cGVyLnNldChrZXksIHZhbHVlKVxuICB9XG5cbiAgLyoqIENvbnZlcnQgdGhlIGNvbGxlY3Rpb24gdG8gYW4gYXJyYXkuICovXG4gIGFycmF5KCk6IFZbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLnZhbHVlcygpXVxuICB9XG5cbiAgLyoqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGlzIGNvbGxlY3Rpb24uICovXG4gIGZpcnN0KCk6IFYgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpLm5leHQoKS52YWx1ZVxuICB9XG5cbiAgLyoqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoaXMgY29sbGVjdGlvbi4gKi9cbiAgbGFzdCgpOiBWIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gWy4uLnRoaXMudmFsdWVzKCldW3RoaXMuc2l6ZSAtIDFdXG4gIH1cblxuICAvKiogUmV0cmlldmUgdGhlIHZhbHVlIG9mIGEgcmFuZG9tIGVsZW1lbnQgaW4gdGhpcyBjb2xsZWN0aW9uLiAqL1xuICByYW5kb20oKTogViB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgYXJyYXkgPSBbLi4udGhpcy52YWx1ZXMoKV1cbiAgICByZXR1cm4gYXJyYXlbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyYXkubGVuZ3RoKV1cbiAgfVxuXG4gIC8qKiBGaW5kIGEgc3BlY2lmaWMgZWxlbWVudCBpbiB0aGlzIGNvbGxlY3Rpb24uICovXG4gIGZpbmQoY2FsbGJhY2s6ICh2YWx1ZTogViwga2V5OiBLKSA9PiBib29sZWFuKTogTm9uTnVsbGFibGU8Vj4gfCB1bmRlZmluZWQge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMua2V5cygpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KGtleSkhXG4gICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSkpIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICAvLyBJZiBub3RoaW5nIG1hdGNoZWRcbiAgfVxuXG4gIC8qKiBGaW5kIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24gdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0dGVybi4gKi9cbiAgZmlsdGVyKGNhbGxiYWNrOiAodmFsdWU6IFYsIGtleTogSykgPT4gYm9vbGVhbik6IENvbGxlY3Rpb248SywgVj4ge1xuICAgIGNvbnN0IHJlbGV2YW50ID0gbmV3IENvbGxlY3Rpb248SywgVj4oKVxuICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXkpKSByZWxldmFudC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlbGV2YW50XG4gIH1cblxuICAvKiogQ29udmVydHMgdGhlIGNvbGxlY3Rpb24gaW50byBhbiBhcnJheSBieSBydW5uaW5nIGEgY2FsbGJhY2sgb24gYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLiAqL1xuICBtYXA8VD4oY2FsbGJhY2s6ICh2YWx1ZTogViwga2V5OiBLKSA9PiBUKTogVFtdIHtcbiAgICBjb25zdCByZXN1bHRzID0gW11cbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChrZXkpIVxuICAgICAgcmVzdWx0cy5wdXNoKGNhbGxiYWNrKHZhbHVlLCBrZXkpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgLyoqIENoZWNrIGlmIG9uZSBvZiB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gbWF0Y2hlcyB0aGUgcGF0dGVybi4gKi9cbiAgc29tZShjYWxsYmFjazogKHZhbHVlOiBWLCBrZXk6IEspID0+IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChrZXkpIVxuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXkpKSByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqIENoZWNrIGlmIGFsbCBvZiB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gbWF0Y2hlcyB0aGUgcGF0dGVybi4gKi9cbiAgZXZlcnkoY2FsbGJhY2s6ICh2YWx1ZTogViwga2V5OiBLKSA9PiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoa2V5KSFcbiAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSkpIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKiogUnVucyBhIGNhbGxiYWNrIG9uIGFsbCBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiwgbWVyZ2luZyB0aGVtIGludG8gYSBzaW5nbGUgdmFsdWUuICovXG4gIHJlZHVjZTxUPihjYWxsYmFjazogKGFjY3VtdWxhdG9yOiBULCB2YWx1ZTogViwga2V5OiBLKSA9PiBULCBpbml0aWFsVmFsdWU/OiBUKTogVCB7XG4gICAgbGV0IGFjY3VtdWxhdG9yOiBUID0gaW5pdGlhbFZhbHVlIVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoa2V5KSFcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBrZXkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xsZWN0aW9uT3B0aW9uczxLLCBWPiB7XG4gIC8qKiBIYW5kbGVyIHRvIGNsZWFuIG91dCB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gZXZlcnkgc28gb2Z0ZW4uICovXG4gIHN3ZWVwZXI/OiBDb2xsZWN0aW9uU3dlZXBlcjxLLCBWPlxuICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIGFsbG93ZWQgaW4gdGhlIGNvbGxlY3Rpb24uICovXG4gIG1heFNpemU/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xsZWN0aW9uU3dlZXBlcjxLLCBWPiB7XG4gIC8qKiBUaGUgZmlsdGVyIHRvIGRldGVybWluZSB3aGV0aGVyIGFuIGVsZW1lbnQgc2hvdWxkIGJlIGRlbGV0ZWQgb3Igbm90ICovXG4gIGZpbHRlcjogKHZhbHVlOiBWLCBrZXk6IEssIC4uLmFyZ3M6IGFueVtdKSA9PiBib29sZWFuXG4gIC8qKiBUaGUgaW50ZXJ2YWwgaW4gd2hpY2ggdGhlIHN3ZWVwZXIgc2hvdWxkIHJ1biAqL1xuICBpbnRlcnZhbDogbnVtYmVyXG4gIC8qKiBUaGUgYm90IG9iamVjdCBpdHNlbGYgKi9cbiAgYm90PzogUGxhY2VIb2xkZXJCb3Rcbn1cbiJdLCJuYW1lcyI6WyJDb2xsZWN0aW9uIiwiTWFwIiwiY29uc3RydWN0b3IiLCJlbnRyaWVzIiwib3B0aW9ucyIsIm1heFNpemUiLCJzd2VlcGVyIiwic3RhcnRTd2VlcGVyIiwiaW50ZXJ2YWxJZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsImZpbHRlciIsImJvdCIsImRlbGV0ZSIsImludGVydmFsIiwic3RvcFN3ZWVwZXIiLCJjaGFuZ2VTd2VlcGVySW50ZXJ2YWwiLCJuZXdJbnRlcnZhbCIsImNoYW5nZVN3ZWVwZXJGaWx0ZXIiLCJuZXdGaWx0ZXIiLCJzZXQiLCJ1bmRlZmluZWQiLCJzaXplIiwiZm9yY2VTZXQiLCJhcnJheSIsInZhbHVlcyIsImZpcnN0IiwibmV4dCIsImxhc3QiLCJyYW5kb20iLCJNYXRoIiwiZmxvb3IiLCJsZW5ndGgiLCJmaW5kIiwiY2FsbGJhY2siLCJrZXlzIiwiZ2V0IiwicmVsZXZhbnQiLCJtYXAiLCJyZXN1bHRzIiwicHVzaCIsInNvbWUiLCJldmVyeSIsInJlZHVjZSIsImluaXRpYWxWYWx1ZSIsImFjY3VtdWxhdG9yIl0sIm1hcHBpbmdzIjoiQUFFQSxPQUFPLE1BQU1BLG1CQUF5QkM7SUFTcENDLFlBQVlDLE9BQTZELEVBQUVDLE9BQWlDLENBQUU7UUFDNUcsS0FBSyxDQUFDRCxXQUFXLEVBQUU7UUFFbkIsSUFBSSxDQUFDRSxPQUFPLEdBQUdELFNBQVNDO1FBRXhCLElBQUksQ0FBQ0QsU0FBU0UsU0FBUztRQUV2QixJQUFJLENBQUNDLFlBQVksQ0FBQ0gsUUFBUUUsT0FBTztJQUNuQztJQUVBQyxhQUFhSCxPQUFnQyxFQUFrQjtRQUM3RCxJQUFJLElBQUksQ0FBQ0UsT0FBTyxFQUFFRSxZQUFZQyxjQUFjLElBQUksQ0FBQ0gsT0FBTyxDQUFDRSxVQUFVO1FBRW5FLElBQUksQ0FBQ0YsT0FBTyxHQUFHRjtRQUNmLElBQUksQ0FBQ0UsT0FBTyxDQUFDRSxVQUFVLEdBQUdFLFlBQVk7WUFDcEMsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsT0FBT0M7Z0JBQ25CLElBQUksQ0FBQyxJQUFJLENBQUNQLE9BQU8sRUFBRVEsT0FBT0YsT0FBT0MsS0FBS1QsUUFBUVcsR0FBRyxHQUFHO2dCQUVwRCxJQUFJ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
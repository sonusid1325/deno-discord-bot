"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Collection", {
    enumerable: true,
    get: function() {
        return Collection;
    }
});
let Collection = class Collection extends Map {
    constructor(entries, options){
        super(entries ?? []);
        this.maxSize = options?.maxSize;
        if (!options?.sweeper) return;
        this.startSweeper(options.sweeper);
    }
    startSweeper(options) {
        if (this.sweeper?.intervalId) clearInterval(this.sweeper.intervalId);
        this.sweeper = options;
        this.sweeper.intervalId = setInterval(()=>{
            this.forEach((value, key)=>{
                if (!this.sweeper?.filter(value, key, options.bot)) return;
                this.delete(key);
                return key;
            });
        }, options.interval);
        return this.sweeper.intervalId;
    }
    stopSweeper() {
        return clearInterval(this.sweeper?.intervalId);
    }
    changeSweeperInterval(newInterval) {
        if (this.sweeper == null) return;
        this.startSweeper({
            filter: this.sweeper.filter,
            interval: newInterval
        });
    }
    changeSweeperFilter(newFilter) {
        if (this.sweeper == null) return;
        this.startSweeper({
            filter: newFilter,
            interval: this.sweeper.interval
        });
    }
    /** Add an item to the collection. Makes sure not to go above the maxSize. */ set(key, value) {
        // When this collection is maxSized make sure we can add first
        if ((this.maxSize !== undefined || this.maxSize === 0) && this.size >= this.maxSize) {
            return this;
        }
        return super.set(key, value);
    }
    /** Add an item to the collection, no matter what the maxSize is. */ forceSet(key, value) {
        return super.set(key, value);
    }
    /** Convert the collection to an array. */ array() {
        return [
            ...this.values()
        ];
    }
    /** Retrieve the value of the first element in this collection. */ first() {
        return this.values().next().value;
    }
    /** Retrieve the value of the last element in this collection. */ last() {
        return [
            ...this.values()
        ][this.size - 1];
    }
    /** Retrieve the value of a random element in this collection. */ random() {
        const array = [
            ...this.values()
        ];
        return array[Math.floor(Math.random() * array.length)];
    }
    /** Find a specific element in this collection. */ find(callback) {
        for (const key of this.keys()){
            const value = this.get(key);
            if (callback(value, key)) return value;
        }
    // If nothing matched
    }
    /** Find all elements in this collection that match the given pattern. */ filter(callback) {
        const relevant = new Collection();
        this.forEach((value, key)=>{
            if (callback(value, key)) relevant.set(key, value);
        });
        return relevant;
    }
    /** Converts the collection into an array by running a callback on all items in the collection. */ map(callback) {
        const results = [];
        for (const key of this.keys()){
            const value = this.get(key);
            results.push(callback(value, key));
        }
        return results;
    }
    /** Check if one of the items in the collection matches the pattern. */ some(callback) {
        for (const key of this.keys()){
            const value = this.get(key);
            if (callback(value, key)) return true;
        }
        return false;
    }
    /** Check if all of the items in the collection matches the pattern. */ every(callback) {
        for (const key of this.keys()){
            const value = this.get(key);
            if (!callback(value, key)) return false;
        }
        return true;
    }
    /** Runs a callback on all items in the collection, merging them into a single value. */ reduce(callback, initialValue) {
        let accumulator = initialValue;
        for (const key of this.keys()){
            const value = this.get(key);
            accumulator = callback(accumulator, value, key);
        }
        return accumulator;
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Db2xsZWN0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgUGxhY2VIb2xkZXJCb3Qge31cblxuZXhwb3J0IGNsYXNzIENvbGxlY3Rpb248SywgVj4gZXh0ZW5kcyBNYXA8SywgVj4ge1xuICAvKipcbiAgICogVGhlIG1heGltdW0gYW1vdW50IG9mIGl0ZW1zIGFsbG93ZWQgaW4gdGhpcyBjb2xsZWN0aW9uLiBUbyBkaXNhYmxlIGNhY2hlLCBzZXQgaXQgMCwgc2V0IHRvIHVuZGVmaW5lZCB0byBtYWtlIGl0IGluZmluaXRlLlxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIG1heFNpemU6IG51bWJlciB8IHVuZGVmaW5lZFxuICAvKiogSGFuZGxlciB0byByZW1vdmUgaXRlbXMgZnJvbSB0aGUgY29sbGVjdGlvbiBldmVyeSBzbyBvZnRlbi4gKi9cbiAgc3dlZXBlcjogKENvbGxlY3Rpb25Td2VlcGVyPEssIFY+ICYgeyBpbnRlcnZhbElkPzogTm9kZUpTLlRpbWVvdXQgfSkgfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3RvcihlbnRyaWVzPzogKFJlYWRvbmx5QXJyYXk8cmVhZG9ubHkgW0ssIFZdPiB8IG51bGwpIHwgTWFwPEssIFY+LCBvcHRpb25zPzogQ29sbGVjdGlvbk9wdGlvbnM8SywgVj4pIHtcbiAgICBzdXBlcihlbnRyaWVzID8/IFtdKVxuXG4gICAgdGhpcy5tYXhTaXplID0gb3B0aW9ucz8ubWF4U2l6ZVxuXG4gICAgaWYgKCFvcHRpb25zPy5zd2VlcGVyKSByZXR1cm5cblxuICAgIHRoaXMuc3RhcnRTd2VlcGVyKG9wdGlvbnMuc3dlZXBlcilcbiAgfVxuXG4gIHN0YXJ0U3dlZXBlcihvcHRpb25zOiBDb2xsZWN0aW9uU3dlZXBlcjxLLCBWPik6IE5vZGVKUy5UaW1lb3V0IHtcbiAgICBpZiAodGhpcy5zd2VlcGVyPy5pbnRlcnZhbElkKSBjbGVhckludGVydmFsKHRoaXMuc3dlZXBlci5pbnRlcnZhbElkKVxuXG4gICAgdGhpcy5zd2VlcGVyID0gb3B0aW9uc1xuICAgIHRoaXMuc3dlZXBlci5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5zd2VlcGVyPy5maWx0ZXIodmFsdWUsIGtleSwgb3B0aW9ucy5ib3QpKSByZXR1cm5cblxuICAgICAgICB0aGlzLmRlbGV0ZShrZXkpXG4gICAgICAgIHJldHVybiBrZXlcbiAgICAgIH0pXG4gICAgfSwgb3B0aW9ucy5pbnRlcnZhbClcblxuICAgIHJldHVybiB0aGlzLnN3ZWVwZXIuaW50ZXJ2YWxJZFxuICB9XG5cbiAgc3RvcFN3ZWVwZXIoKTogdm9pZCB7XG4gICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwodGhpcy5zd2VlcGVyPy5pbnRlcnZhbElkKVxuICB9XG5cbiAgY2hhbmdlU3dlZXBlckludGVydmFsKG5ld0ludGVydmFsOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zd2VlcGVyID09IG51bGwpIHJldHVyblxuXG4gICAgdGhpcy5zdGFydFN3ZWVwZXIoeyBmaWx0ZXI6IHRoaXMuc3dlZXBlci5maWx0ZXIsIGludGVydmFsOiBuZXdJbnRlcnZhbCB9KVxuICB9XG5cbiAgY2hhbmdlU3dlZXBlckZpbHRlcihuZXdGaWx0ZXI6ICh2YWx1ZTogViwga2V5OiBLLCBib3Q6IFBsYWNlSG9sZGVyQm90KSA9PiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3dlZXBlciA9PSBudWxsKSByZXR1cm5cblxuICAgIHRoaXMuc3RhcnRTd2VlcGVyKHsgZmlsdGVyOiBuZXdGaWx0ZXIsIGludGVydmFsOiB0aGlzLnN3ZWVwZXIuaW50ZXJ2YWwgfSlcbiAgfVxuXG4gIC8qKiBBZGQgYW4gaXRlbSB0byB0aGUgY29sbGVjdGlvbi4gTWFrZXMgc3VyZSBub3QgdG8gZ28gYWJvdmUgdGhlIG1heFNpemUuICovXG4gIHNldChrZXk6IEssIHZhbHVlOiBWKTogdGhpcyB7XG4gICAgLy8gV2hlbiB0aGlzIGNvbGxlY3Rpb24gaXMgbWF4U2l6ZWQgbWFrZSBzdXJlIHdlIGNhbiBhZGQgZmlyc3RcbiAgICBpZiAoKHRoaXMubWF4U2l6ZSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMubWF4U2l6ZSA9PT0gMCkgJiYgdGhpcy5zaXplID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuc2V0KGtleSwgdmFsdWUpXG4gIH1cblxuICAvKiogQWRkIGFuIGl0ZW0gdG8gdGhlIGNvbGxlY3Rpb24sIG5vIG1hdHRlciB3aGF0IHRoZSBtYXhTaXplIGlzLiAqL1xuICBmb3JjZVNldChrZXk6IEssIHZhbHVlOiBWKTogdGhpcyB7XG4gICAgcmV0dXJuIHN1cGVyLnNldChrZXksIHZhbHVlKVxuICB9XG5cbiAgLyoqIENvbnZlcnQgdGhlIGNvbGxlY3Rpb24gdG8gYW4gYXJyYXkuICovXG4gIGFycmF5KCk6IFZbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLnZhbHVlcygpXVxuICB9XG5cbiAgLyoqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGlzIGNvbGxlY3Rpb24uICovXG4gIGZpcnN0KCk6IFYgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnZhbHVlcygpLm5leHQoKS52YWx1ZVxuICB9XG5cbiAgLyoqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBlbGVtZW50IGluIHRoaXMgY29sbGVjdGlvbi4gKi9cbiAgbGFzdCgpOiBWIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gWy4uLnRoaXMudmFsdWVzKCldW3RoaXMuc2l6ZSAtIDFdXG4gIH1cblxuICAvKiogUmV0cmlldmUgdGhlIHZhbHVlIG9mIGEgcmFuZG9tIGVsZW1lbnQgaW4gdGhpcyBjb2xsZWN0aW9uLiAqL1xuICByYW5kb20oKTogViB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgYXJyYXkgPSBbLi4udGhpcy52YWx1ZXMoKV1cbiAgICByZXR1cm4gYXJyYXlbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyYXkubGVuZ3RoKV1cbiAgfVxuXG4gIC8qKiBGaW5kIGEgc3BlY2lmaWMgZWxlbWVudCBpbiB0aGlzIGNvbGxlY3Rpb24uICovXG4gIGZpbmQoY2FsbGJhY2s6ICh2YWx1ZTogViwga2V5OiBLKSA9PiBib29sZWFuKTogTm9uTnVsbGFibGU8Vj4gfCB1bmRlZmluZWQge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMua2V5cygpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KGtleSkhXG4gICAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSkpIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICAvLyBJZiBub3RoaW5nIG1hdGNoZWRcbiAgfVxuXG4gIC8qKiBGaW5kIGFsbCBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24gdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0dGVybi4gKi9cbiAgZmlsdGVyKGNhbGxiYWNrOiAodmFsdWU6IFYsIGtleTogSykgPT4gYm9vbGVhbik6IENvbGxlY3Rpb248SywgVj4ge1xuICAgIGNvbnN0IHJlbGV2YW50ID0gbmV3IENvbGxlY3Rpb248SywgVj4oKVxuICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXkpKSByZWxldmFudC5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJlbGV2YW50XG4gIH1cblxuICAvKiogQ29udmVydHMgdGhlIGNvbGxlY3Rpb24gaW50byBhbiBhcnJheSBieSBydW5uaW5nIGEgY2FsbGJhY2sgb24gYWxsIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLiAqL1xuICBtYXA8VD4oY2FsbGJhY2s6ICh2YWx1ZTogViwga2V5OiBLKSA9PiBUKTogVFtdIHtcbiAgICBjb25zdCByZXN1bHRzID0gW11cbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChrZXkpIVxuICAgICAgcmVzdWx0cy5wdXNoKGNhbGxiYWNrKHZhbHVlLCBrZXkpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgLyoqIENoZWNrIGlmIG9uZSBvZiB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gbWF0Y2hlcyB0aGUgcGF0dGVybi4gKi9cbiAgc29tZShjYWxsYmFjazogKHZhbHVlOiBWLCBrZXk6IEspID0+IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmtleXMoKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChrZXkpIVxuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXkpKSByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqIENoZWNrIGlmIGFsbCBvZiB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gbWF0Y2hlcyB0aGUgcGF0dGVybi4gKi9cbiAgZXZlcnkoY2FsbGJhY2s6ICh2YWx1ZTogViwga2V5OiBLKSA9PiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoa2V5KSFcbiAgICAgIGlmICghY2FsbGJhY2sodmFsdWUsIGtleSkpIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKiogUnVucyBhIGNhbGxiYWNrIG9uIGFsbCBpdGVtcyBpbiB0aGUgY29sbGVjdGlvbiwgbWVyZ2luZyB0aGVtIGludG8gYSBzaW5nbGUgdmFsdWUuICovXG4gIHJlZHVjZTxUPihjYWxsYmFjazogKGFjY3VtdWxhdG9yOiBULCB2YWx1ZTogViwga2V5OiBLKSA9PiBULCBpbml0aWFsVmFsdWU/OiBUKTogVCB7XG4gICAgbGV0IGFjY3VtdWxhdG9yOiBUID0gaW5pdGlhbFZhbHVlIVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoa2V5KSFcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBrZXkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xsZWN0aW9uT3B0aW9uczxLLCBWPiB7XG4gIC8qKiBIYW5kbGVyIHRvIGNsZWFuIG91dCB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24gZXZlcnkgc28gb2Z0ZW4uICovXG4gIHN3ZWVwZXI/OiBDb2xsZWN0aW9uU3dlZXBlcjxLLCBWPlxuICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIGFsbG93ZWQgaW4gdGhlIGNvbGxlY3Rpb24uICovXG4gIG1heFNpemU/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xsZWN0aW9uU3dlZXBlcjxLLCBWPiB7XG4gIC8qKiBUaGUgZmlsdGVyIHRvIGRldGVybWluZSB3aGV0aGVyIGFuIGVsZW1lbnQgc2hvdWxkIGJlIGRlbGV0ZWQgb3Igbm90ICovXG4gIGZpbHRlcjogKHZhbHVlOiBWLCBrZXk6IEssIC4uLmFyZ3M6IGFueVtdKSA9PiBib29sZWFuXG4gIC8qKiBUaGUgaW50ZXJ2YWwgaW4gd2hpY2ggdGhlIHN3ZWVwZXIgc2hvdWxkIHJ1biAqL1xuICBpbnRlcnZhbDogbnVtYmVyXG4gIC8qKiBUaGUgYm90IG9iamVjdCBpdHNlbGYgKi9cbiAgYm90PzogUGxhY2VIb2xkZXJCb3Rcbn1cbiJdLCJuYW1lcyI6WyJDb2xsZWN0aW9uIiwiTWFwIiwiY29uc3RydWN0b3IiLCJlbnRyaWVzIiwib3B0aW9ucyIsIm1heFNpemUiLCJzd2VlcGVyIiwic3RhcnRTd2VlcGVyIiwiaW50ZXJ2YWxJZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsImZpbHRlciIsImJvdCIsImRlbGV0ZSIsImludGVydmFsIiwic3RvcFN3ZWVwZXIiLCJjaGFuZ2VTd2VlcGVySW50ZXJ2YWwiLCJuZXdJbnRlcnZhbCIsImNoYW5nZVN3ZWVwZXJGaWx0ZXIiLCJuZXdGaWx0ZXIiLCJzZXQiLCJ1bmRlZmluZWQiLCJzaXplIiwiZm9yY2VTZXQiLCJhcnJheSIsInZhbHVlcyIsImZpcnN0IiwibmV4dCIsImxhc3QiLCJyYW5kb20iLCJNYXRoIiwiZmxvb3IiLCJsZW5ndGgiLCJmaW5kIiwiY2FsbGJhY2siLCJrZXlzIiwiZ2V0IiwicmVsZXZhbnQiLCJtYXAiLCJyZXN1bHRzIiwicHVzaCIsInNvbWUiLCJldmVyeSIsInJlZHVjZSIsImluaXRpYWxWYWx1ZSIsImFjY3VtdWxhdG9yIl0sIm1hcHBpbmdzIjoiOzs7OytCQUVhQTs7O2VBQUFBOzs7QUFBTixJQUFBLEFBQU1BLGFBQU4sTUFBTUEsbUJBQXlCQztJQVNwQ0MsWUFBWUMsT0FBNkQsRUFBRUMsT0FBaUMsQ0FBRTtRQUM1RyxLQUFLLENBQUNELFdBQVcsRUFBRTtRQUVuQixJQUFJLENBQUNFLE9BQU8sR0FBR0QsU0FBU0M7UUFFeEIsSUFBSSxDQUFDRCxTQUFTRSxTQUFTO1FBRXZCLElBQUksQ0FBQ0MsWUFBWSxDQUFDSCxRQUFRRSxPQUFPO0lBQ25DO0lBRUFDLGFBQWFILE9BQWdDLEVBQWtCO1FBQzdELElBQUksSUFBSSxDQUFDRSxPQUFPLEVBQUVFLFlBQVlDLGNBQWMsSUFBSSxDQUFDSCxPQUFPLENBQUNFLFVBQVU7UUFFbkUsSUFBSSxDQUFDRixPQUFPLEdBQUdGO1FBQ2YsSUFBSSxDQUFDRSxPQUFPLENBQUNFLFVBQVUsR0FBR0UsWUFBWTtZQUNwQyxJQUFJLENBQUNDLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztnQkFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQ1AsT0FBTyxFQUFFUSxPQUFPRixPQUFPQyxL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